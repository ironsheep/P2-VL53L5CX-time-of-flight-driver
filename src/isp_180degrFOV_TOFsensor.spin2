'' =================================================================================================
''
''   File....... isp_180degrFOV_TOFsensor.spin2
''   Purpose.... Object Providing interface to 4x VL53L5CX time-of-flight sensors acting as a single TOF sensor w/180° Field of View
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2022 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Sep 2022
''   Updated.... 11 Sep 2022
''
'' =================================================================================================
CON { PUBLIC Interface Constants }

    DRVR_DIDNT_RESPOND = (-1)

CON { fixed io pins }

    RX1      = 63  { I }                                          ' programming / debug
    TX1      = 62  { O }

    SF_CS    = 61  { O }                                          ' serial flash
    SF_SCK   = 60  { O }
    SF_SDO   = 59  { O }
    SF_SDI   = 58  { I }

    SD_SCK   = 61  { O }                                          ' sd card
    SD_CS    = 60  { O }
    SD_SDI   = 59  { O }
    SD_SDO   = 58  { I }

    SDA1     = 57  { IO }                                         ' i2c (optional)
    SCL1     = 56  { IO }


CON { basic constants }

    TEST_WORD_CT = 4

    ' internal driver commands
    #0, DC_UNKNOWN, DC_IDLE, DC_START, DC_CFG_BUS1, DC_CFG_BUS2, DC_RUN, DC_STOP, DC_SET_PARM, DC_GET_PARM
    #$E0, RSP_UNKNOWN, RSP_OK, RSP_ERROR

    #$10, PID_RANGING_FREQUENCY, PID_RANGING_MODE, PID_RESOLUTION, PID_POWER_MODE
    #$14, PID_INTEGRATION_TIME, PID_SHARPENER_PERCENT, PID_TARGET_ORDER

    STACK_SIZE_LONGS = 128  ' was 64

DAT { run-time condition vars }

    bUseHDMI        LONG    TRUE        ' set to TRUE to enable HDMI use/output
    showHDMIDebug   LONG    FALSE


OBJ { our sensors }

    pcf8575         : "isp_pcf8575"                 ' our device under test
    tofSensor[4]    : "isp_vl53l5cx"                      ' our device under test
    tvDebug         : "isp_hdmi_debug"              ' Our HDMI display

pub null()
'' This is not a top-level object

CON ' -------------- SET UP --------------

PUB setHDMIBasePin(pHDMIbase)
'' Assign pins to HDMI Eval Adapter
    pinHDMIbase := pHDMIbase

PUB setTofPins(nBusNbr, pSDA, pSCL)
'' Assign pins to I2C Bus #[0-1]
''  (we have two TOF sensors on each I2C bus)
    case nBusNbr
        2:
            ' devices 1 and 2
            tofSensor[0].setPinsAndID(pSDA, pSCL, 1)
            tofSensor[1].setPinsAndID(pSDA, pSCL, 2)
        1:
            ' devices 3 and 4
            tofSensor[2].setPinsAndID(pSDA, pSCL, 3)
            tofSensor[3].setPinsAndID(pSDA, pSCL, 4)
        other:
            debug("180: ERROR bad I2C bus number, aborted!")
            abort

PUB setExpanderPins(pSDA, pSCL, pinINT)
'' Assign pins to I2C bus for our PCF8575 I/O Expander
'' this listens to and controls all 4 TOF sensors
    pcf8575.setPins(pSDA, pSCL, pinINT)

PUB start() : Ok | nGroups, pGroupTitles, pGroupNames, pGroupVarCts, pGroupVars, imageWidth, bDvcFound, eDvcStatus, bDataReturned, bDataUnloaded, readCt
'' Start all backend objects and our Overall driver Cog
    if bUseHDMI
        tvDebug.start(pinHDMIbase, @screenTitle)

        nGroups, pGroupTitles, pGroupNames, pGroupVarCts, pGroupVars := getDebugData()
        debug("* Received: ", udec(nGroups), uhex_long(pGroupTitles), uhex_long(pGroupNames), uhex_long(pGroupVarCts), uhex_long(pGroupVars))
        tvDebug.registerDisplay(nGroups, pGroupTitles, pGroupNames, pGroupVarCts, pGroupVars)
    else
        showHDMIDebug := FALSE  ' force this off is not using HDMI

    ok := cog := cogspin(NEWCOG, taskRun180FovSensor(@nDriverCmd, @nDriverArg, @drvrArgValue, @drvrResponse), @taskStack) + 1

    'wait driver running
    debug("* waiting for driver started")
    repeat until nDriverCmd <> DC_IDLE

    ' tell driver to set-up bus 1
    debug("* Starting BUS 1 of 2")
    nDriverCmd := DC_CFG_BUS1

    debug("* waiting for BUS 1 ready")
    repeat until drvrResponse <> RSP_UNKNOWN
    if drvrResponse == RSP_ERROR
        debug("* waiting BUS 1 ready")


    ' tell driver to set-up bus 2

PUB stop()
'' Stop our driver-Cog and all backend objects
    ' shtudown sensing
    nDriverCmd := DC_STOP
    debug("* waiting for driver shutdown")
    repeat until nDriverCmd <> DC_STOP

    debug("* is shutdown. Stopping all")
    ' stop our cog
    if cog
        cogstop(cog - 1)
        cog := 0


CON ' -------------- COMMAND Interface --------------

PUB setParm(nParmId, nParmValue) : nResponse | bTimedOut
'' NOT WORKING: Example drive command,,,
    drvrArg := nParmId
    drvrArgValue := nParmValue
    nDriverCmd := DC_SET_PARM
    ' wait for command to be accepted
    bTimedOut := waitForCommandAccepted()

    nResponse := DRVR_DIDNT_RESPOND
    if not bTimedOut
        nResponse := drvrResponse

PUB getParm(nParmId) : nParmValue | bTimedOut
'' NOT WORKING: Example drive command,,,
    drvrArg := nParmId

    ' wait for command to be accepted
    bTimedOut := waitForCommandAccepted()

    nParmValue := DRVR_DIDNT_RESPOND
    if not bTimedOut
        nParmValue := drvrResponse

PUB enableSensing(bEnable) : nResponse | bTimedOut  ' turn sensing on/off
'' NOT WORKING: Example drive command,,,
    ' block until prior message accepted
    'repeat
    '    if nDriverArg <> 0
    '        waitms(50)
    '    else
     '       quit
    ' request next message
    nDriverCmd := (bEnable) ? DC_START : DC_STOP
    ' wait for command to be accepted
    bTimedOut := waitForCommandAccepted()
    nResponse := DRVR_DIDNT_RESPOND
    if not bTimedOut
        nResponse := drvrResponse



CON ' -------------- PRIVATE (Utility) Methods --------------

PRI waitForCommandAccepted() : bTimedOut
' wait for ack or timeout
    bTimedOut := TRUE
    repeat 200
        if nDriverCmd == DC_IDLE
            bTimedOut := FALSE
            quit
        waitms(10)

    if bTimedOut
        debug("180: request timed-out. ERROR?")

VAR { driver internal variables }
    LONG    cog
    LONG    pinHDMIbase

CON ' -------------- TASK in own COG --------------

DAT { debug display data }

    screenTitle     BYTE    "-- 180° Field of View Sensor Debug --", 0

    nDriverCmd      long    DC_UNKNOWN
    nDriverArg      long    0
    drvrResponse    long    0
    drvrArgValue    long    0
    taskStack       long    0[STACK_SIZE_LONGS]

    bDevicePreset   long    FALSE

PRI taskRun180FovSensor(pDriverCmd, pDriverArg, pDriverArgValue, pDriverResponse) | nbit, ok
    'repeat  ' stop here !!!
    parmPtrCmd          := pDriverCmd
    parmPtrArg          := pDriverArg
    parmPtrArgValue     := pDriverArgValue
    parmPtrResponse     := pDriverResponse

    Debug("TSK: Starting...")
    ' init device complex
    ' ensure PCF8575 is up
    bDevicePreset := pcf8575.startUsingPins()
    if NOT bDevicePreset
        debug("TSK:PCF8575 not responding!")

    ' Condition VL53L5CX device I/O lines driven by PCF8575
    '   LPn to LOW
    '   INTb as input
    '   PWREN to HIGH
    '   I2C_RST to HIGH
    repeat nbit from 0 to 15
        if nbit >= 8 and nbit <= 11
            pcf8575.setBitDirection(nbit, pcf8575.BIT_IS_INPUT)
        else
            pcf8575.setBitDirection(nbit, pcf8575.BIT_IS_OUTPUT)
            pcf8575.setOutputBitValue(nbit, 1)

    dropLPnBits()
    ok := setTOFAddresses()
    if not ok
        debug("TSK:ERROR: task not started")
    else
    ' mark that driver is runnig
        Debug("TSK: Running...")
        LONG[pDriverResponse] := RSP_UNKNOWN
        LONG[pDriverCmd] := DC_IDLE

        repeat
            drvrCommand := LONG[pDriverCmd]
            drvrArg := LONG[pDriverArg]

            if drvrCommand <> DC_RUN and drvrCommand <> DC_IDLE
                handleDriverCommand()

            waitms(1000)    ' idle for 1 sec.

PRI dropLPnBits() | nBit
' Clear all 4 LPn bits (disables TOF device COMM.)
    ' LPn port bits are 4-7
    repeat nbit from 4 to 7
        pcf8575.setOutputBitValue(nbit, 0)

PRI enableLPn(nLPnNbr) | nBit
' LPn bits are numbered 1-4 for our 4 TOF sensors 1-4 [LPn bits of Expander are 4-7]
    if nLPnNbr >= 1 and nLPnNbr <= 4
        nBit := (nLPnNbr - 1) + 4   ' +4: LPn port bits are 4-7
        pcf8575.setOutputBitValue(nbit, 1)

PRI disableLPn(nLPnNbr) | nBit
' LPn bits are numbered 1-4 for our 4 TOF sensors 1-4 [LPn bits of Expander are 4-7]
    if nLPnNbr >= 1 and nLPnNbr <= 4
        nBit := (nLPnNbr - 1) + 4   ' +4: LPn port bits are 4-7
        pcf8575.setOutputBitValue(nbit, 0)

DAT
    '                 TOF #   1    2    3    4
    '             I2C Bus #   2    2    1    1
    TOFdeviceAddrTbl   BYTE    $54, $56, $58, $5A

PRI setTOFAddresses() : ok | nTOFNbr, bDevicePresent, eDvcStatus
    ok := TRUE
    repeat nTOFNbr from 1 to 4
        enableLPn(nTOFNbr)
        bDevicePresent := tofSensor.startUsingPins()
        if not bDevicePresent
            debug("TSK:ERROR missing TOF device, aborting startup")
            ok := FALSE
            quit
        eDvcStatus :=tofSensor.setI2CAddress(BYTE[@TOFdeviceAddrTbl][nTOFNbr - 1])
        if eDvcStatus <> tofSensor.VL53L5CX_STATUS_OK
            debug("TSK:ERROR failed to set device i2c addr, aborting startup")
            ok := FALSE
            quit
    disableLPn(nTOFNbr)

PRI handleDriverCommand() | bCanGoIdle, nCommand
    bCanGoIdle := FALSE
    nCommand := LONG[parmPtrCmd]
    debug("TSK:Handling ", udec(nCommand))
    case nCommand
        DC_STOP:
            ' stop our back-end comms
            tofSensor[0].stop()
            tofSensor[1].stop()
            tofSensor[2].stop()
            tofSensor[3].stop()
            pcf8575.stop()
            tvDebug.stop()
            bCanGoIdle := TRUE
        DC_START:

        DC_SET_PARM:
            handleSetupChange()
        DC_GET_PARM:
            handleSetupQuery()

        other:
            ' nothing to do here

    ' if we are allowed to ACK command, do so
    if bCanGoIdle
        ' indicate we are done processing command
        ackDriverCommand()

PRI reAddressTOFsensors()
    ' condition all OUTPUT lines to 4 sensors
    ' set all LPn's low (turn of everybody)
    ' for ea. sensor
    '    enable LPn then set I2C address
    '    ensure TOF now responds at new address
    ' DONE

PRI handleSetupChange()

PRI handleSetupQuery()

PRI ackDriverCommand()
        ' indicate we are done processing command
        long[parmPtrCmd] := DC_IDLE

DAT { TASK Data }

    drvrCommand     LONG    0
    drvrArg         LONG    0

    parmPtrCmd          LONG    0
    parmPtrArg          LONG    0
    parmPtrArgValue     LONG    0
    parmPtrResponse     LONG    0

CON { --- HDMI Debug Support --- }

CON { Constants for HDMI Debug }

    DBG_GROUPS_CT = 3
    DBG_MAX_VARS_IN_GROUP = 7

VAR { * Data Structure for HDMI Debug * }

    LONG    pTitlesAr[DBG_GROUPS_CT + 1]    ' first value is max vars
    LONG    pVarCtAr[DBG_GROUPS_CT]
    LONG    pNamesAr[DBG_GROUPS_CT * DBG_MAX_VARS_IN_GROUP]
    LONG    pValsAr[DBG_GROUPS_CT*DBG_MAX_VARS_IN_GROUP]

DAT { Literals for HDMI Debug }

' acelerometer data
    nameTitle1  BYTE    "Accel",0
    name10      BYTE    "rawX",0
    name11      BYTE    "rawY",0
    name12      BYTE    "rawZ",0
    name13      BYTE    "X",0
    name14      BYTE    "Y",0
    name15      BYTE    "Z",0
nextAddr1
    dataLen1     LONG    @nextAddr1 - @nameTitle1

' magnetometer data
    nameTitle2  BYTE    "Mag",0
    name20      BYTE    "rawX",0
    name21      BYTE    "rawY",0
    name22      BYTE    "rawZ",0
    name23      BYTE    "X",0
    name24      BYTE    "Y",0
    name25      BYTE    "Z",0
nextAddr2
    dataLen2     LONG    @nextAddr2 - @nameTitle2

' gyroscope data
    nameTitle3  BYTE    "Gyro",0
    name30      BYTE    "rawX",0
    name31      BYTE    "rawY",0
    name32      BYTE    "rawZ",0
    name33      BYTE    "X",0
    name34      BYTE    "Y",0
    name35      BYTE    "Z",0
nextAddr3
    dataLen3     LONG    @nextAddr3 - @nameTitle3


PRI loadDisplayList() | nGrpOffset, nValsGrpOffset, nVarsInGroup
' do internal one-time setup of driver debug data
    nGrpOffset := 0
    nVarsInGroup := 6
    LONG[@pTitlesAr][nGrpOffset] := @nameTitle1
    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup
    ' populate the empty name/value ptr tables
    nValsGrpOffset := nGrpOffset * DBG_MAX_VARS_IN_GROUP
    LONG[@pNamesAr][nValsGrpOffset + 0] := @name10
    LONG[@pNamesAr][nValsGrpOffset + 1] := @name11
    LONG[@pNamesAr][nValsGrpOffset + 2] := @name12
    LONG[@pNamesAr][nValsGrpOffset + 3] := @name13
    LONG[@pNamesAr][nValsGrpOffset + 4] := @name14
    LONG[@pNamesAr][nValsGrpOffset + 5] := @name15
    LONG[@pValsAr][nValsGrpOffset + 0] := @rawAccelX
    LONG[@pValsAr][nValsGrpOffset + 1] := @rawAccelY
    LONG[@pValsAr][nValsGrpOffset + 2] := @rawAccelZ
    LONG[@pValsAr][nValsGrpOffset + 3] := @accelX
    LONG[@pValsAr][nValsGrpOffset + 4] := @accelY
    LONG[@pValsAr][nValsGrpOffset + 5] := @accelZ

    ' reset unused
    unused0 := 0
    unused1 := 0

    nGrpOffset := 1
    nVarsInGroup := 6
    LONG[@pTitlesAr][nGrpOffset] := @nameTitle2
    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup
     ' populate the empty name/value ptr tables
    nValsGrpOffset := nGrpOffset * DBG_MAX_VARS_IN_GROUP ' mult by vars in prior group
    LONG[@pNamesAr][nValsGrpOffset + 0] := @name20
    LONG[@pNamesAr][nValsGrpOffset + 1] := @name21
    LONG[@pNamesAr][nValsGrpOffset + 2] := @name22
    LONG[@pNamesAr][nValsGrpOffset + 3] := @name23
    LONG[@pNamesAr][nValsGrpOffset + 4] := @name24
    LONG[@pNamesAr][nValsGrpOffset + 5] := @name25
    LONG[@pValsAr][nValsGrpOffset + 0] := @rawMagX
    LONG[@pValsAr][nValsGrpOffset + 1] := @rawMagY
    LONG[@pValsAr][nValsGrpOffset + 2] := @rawMagZ
    LONG[@pValsAr][nValsGrpOffset + 3] := @magX
    LONG[@pValsAr][nValsGrpOffset + 4] := @magY
    LONG[@pValsAr][nValsGrpOffset + 5] := @magZ

    nGrpOffset := 2
    nVarsInGroup := 6
    LONG[@pTitlesAr][nGrpOffset] := @nameTitle3
    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup
     ' populate the empty name/value ptr tables
    nValsGrpOffset := nGrpOffset * DBG_MAX_VARS_IN_GROUP ' mult by vars in prior group
    LONG[@pNamesAr][nValsGrpOffset + 0] := @name30
    LONG[@pNamesAr][nValsGrpOffset + 1] := @name31
    LONG[@pNamesAr][nValsGrpOffset + 2] := @name32
    LONG[@pNamesAr][nValsGrpOffset + 3] := @name33
    LONG[@pNamesAr][nValsGrpOffset + 4] := @name34
    LONG[@pNamesAr][nValsGrpOffset + 5] := @name35
    LONG[@pValsAr][nValsGrpOffset + 0] := @rawGyroX
    LONG[@pValsAr][nValsGrpOffset + 1] := @rawGyroY
    LONG[@pValsAr][nValsGrpOffset + 2] := @rawGyroZ
    LONG[@pValsAr][nValsGrpOffset + 3] := @gyroX
    LONG[@pValsAr][nValsGrpOffset + 4] := @gyroY
    LONG[@pValsAr][nValsGrpOffset + 5] := @gyroZ


    ' tell our table size to reader
    nGrpOffset := 3
    LONG[@pTitlesAr][nGrpOffset] := DBG_MAX_VARS_IN_GROUP

PUB getDebugData() : nGroups, pGroupTitles, pGroupNames, pGroupVarCts, pGroupVars | tmpAbsPtr
'' Return pointers to HDMI-debug data structures for this motor-object instance
    loadDisplayList()
    nGroups := DBG_GROUPS_CT
    pGroupTitles := @pTitlesAr         ' pStr := long[pTitlesAr][grpIdx]
    pGroupVarCts := @pVarCtAr          ' nNbrGrpVars := long[pVarCtAr][grpIdx]
    pGroupNames := @pNamesAr           ' pGrpNameAr := long[pNamesAr][grpIdx], pVarName := long[pNameAr][varIdx]  where varIdx is from 0 to nNbrGrpVars - 1
    pGroupVars := @pValsAr             ' pGrpLongVar := long[pValsAr][grpIdx][varIdx]  where varIdx is from 0 to nNbrGrpVars - 1

VAR { captured sensor data }

    long rawMagX
    long rawMagY
    long rawMagZ
    long magX
    long magY
    long magZ

    long rawAccelX
    long rawAccelY
    long rawAccelZ
    long accelX
    long accelY
    long accelZ

    long rawGyroX
    long rawGyroY
    long rawGyroZ
    long gyroX
    long gyroY
    long gyroZ

    long roll
    long pitch
    long yaw
    long unused0
    long unused1
    long senseTimeMS

    long ticks1ms
    long ticks1us
    long ticks125ms

CON { license }

{{
 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2022 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
