'' =================================================================================================
''
''   File....... isp_vl53l5cx.spin2
''   Purpose.... Interface to VL53L5CX sensor via I2C
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2022 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Aug 2022
''   Updated.... 20 Aug 2022
''
'' =================================================================================================

 {{

    Satel Breakout Board IO Assignments

            ┌──────────────────┐
        <-- │ [ ] INT          │
            │                  │
        --> │ (*) I2C_RST      │
            │                  │
        <-> │ (*) SDA          │
            │                  │
        --> │ (*) SCL          │
            │                  │
        --> │ (*) LPn          │
            │                  │
        --> │ (*) PWREN        │
            │                  │
            │ (*) A VDD - 3v3  │
            │                  │
            │ (*) IO VDD - 3v3 │
            │                  │
            │ [*] GND          │
            ┌──────────────────┐
            │                  │
            │      Sensor      │
            │                  │
            └──────────────────/

    REF Board: https://www.mikroe.com/mpu-9dof-click
    REF MPU9250A Datasheet: https://download.mikroe.com/documents/datasheets/PS-MPU-9250A-01-v1.1.pdf
    REF User Manual: https://download.mikroe.com/documents/add-on-boards/click/mpu-9dof/mpu-9dof-click-manual-v100.pdf
    REF Register Manual: https://inertialelements.com/documents/resources_page/MPU-register-manual.pdf

}}

CON { Interface constants }

' devcie found (or not) responses
#0, DVC_NOT_FOUND, DVC_ADDR0, DVC_ADDR1

' method return values
'  VL53L5CX_STATUS_OK indicates that VL53L5 sensor has no error.
    VL53L5CX_STATUS_OK              = 0
'  VL53L5CX_MCU_ERROR is used to indicate a MCU issue.
    VL53L5CX_MCU_ERROR              = 66
    VL53L5CX_STATUS_INVALID_PARAM   = 127
'  VL53L5CX_STATUS_ERROR indicates that something is wrong (value, I2C access, ...)
    VL53L5CX_STATUS_ERROR           = (-1)

' The default power mode is VL53L5CX_POWER_MODE_WAKEUP. User can choose
'  the mode VL53L5CX_POWER_MODE_SLEEP to save power consumption is the device
'  is not used. The low power mode retains the firmware and the configuration.
'  Both modes can be changed using function setPowerMode().
    VL53L5CX_POWER_MODE_SLEEP       = 0
    VL53L5CX_POWER_MODE_WAKEUP      = 1

'  VL53L5CX_RANG_MODE_CONTINUOUS and
'  VL53L5CX_RANG_MODE_AUTONOMOUS are used to change the ranging mode.
'  Autonomous mode can be used to set a precise integration time, whereas
'  continuous is always maximum.
    VL53L5CX_RANG_MODE_CONTINUOUS   = 1
    VL53L5CX_RANG_MODE_AUTONOMOUS   = 3

'  VL53L5CX_TGT_ORDER_STRONGEST or VL53L5CX_TGT_ORDER_CLOSEST
'    are used to select the target order for data output.
    VL53L5CX_TGT_ORDER_CLOSEST      = 1
    VL53L5CX_TGT_ORDER_STRONGEST    = 2

'  VL53L5CX_RESOLUTION_4X4 or VL53L5CX_RESOLUTION_8X8 allows
'   setting sensor in 4x4 mode or 8x8 mode, using function
'   setResolution().
    VL53L5CX_RESOLUTION_4X4         = 16
    VL53L5CX_RESOLUTION_8X8         = 64

'  VL53L5CX_NB_TGT_PER_ZONE is used to define the number of target per zone sent
'   through I2C. This value can be changed by user, in order to tune I2C
'   transaction, and also the total memory size (a lower number of target per
'   zone means a lower RAM). The value must be between 1 and 4.
    ' (driver tunable)
    VL53L5CX_NB_TGT_PER_ZONE	    = 1


con { fixed io pins }

  RX1      = 63  { I }                                          ' programming / debug
  TX1      = 62  { O }

  SF_CS    = 61  { O }                                          ' serial flash
  SF_SCK   = 60  { O }
  SF_SDO   = 59  { O }
  SF_SDI   = 58  { I }

OBJ { Objects this object needs }

    i2c_bus     : "jm_i2c"                                  ' i2c coms

VAR { Instance Variables - Global }

    LONG    pin_scl
    LONG    pin_sda
    LONG    pin_int
    LONG    pin_rst
    LONG    pin_lpn
    LONG    pin_pwren

    LONG    bDidCalibrate
    LONG    bPinsSetUp
    LONG    bDeviceFound
    LONG    dvcI2CAddr

    BYTE    bShowDebug

CON { driver Settings }

    PULL_UP_VL53L5CX_I2C = i2c_bus.PU_NONE
    FREQ_IN_KHZ_VL53L5CX_I2C = 1064              ' use 1 MHZ (1000 KHz) NOTE: at 270MHz clock: 1000 is 950KHz, 1010 is 965KHz, 1035 is 980KHz, 1050 same,

    VL53L5CX_I2C_ADDR_0      = $52
    VL53L5CX_I2C_ADDR_1      = $54

PUB enableDebug(bEnable)
    '' turn on/off file internal debug messaging (bEnable = T/F where T means show debug messages from this object)
    bShowDebug := bEnable
    if bShowDebug
        'debug(`snsLog 10 '* DBG ON' 10)
    else
        'debug(`snsLog 10 '* DBG off' 10)

PUB init(pinINT, pinRST, pinSDA, pinSCL, pinLPN, pinPWREN)
    '' Initialize the output pins (quiet the device so we can trigger LA)
    'debug(`term snsLog pos 500 30 size 50 14 textsize 12 color green)

    bDidCalibrate := FALSE ' initially we say the device is NOT calibrated
    bShowDebug := FALSE

    bPinsSetUp := setupPins(pinINT, pinRST, pinSDA, pinSCL, pinLPN, pinPWREN)  ' configure pin numbers if not already
    if bPinsSetUp
        floatPins()
        ' have the driver force its own pins quiet
        i2c_bus.quiesce(pin_scl, pin_sda, PULL_UP_VL53L5CX_I2C)

PUB start(pinINT, pinRST, pinSDA, pinSCL, pinLPN, pinPWREN) : bDevicePresent
    '' Start the device running
    bDidCalibrate := FALSE ' initially we say the device is NOT calibrated
    bShowDebug := FALSE

    bPinsSetUp := setupPins(pinINT, pinRST, pinSDA, pinSCL, pinLPN, pinPWREN)  ' configure pin numbers if not already
    if bPinsSetUp
        i2c_bus.setup(pin_scl, pin_sda, FREQ_IN_KHZ_VL53L5CX_I2C, PULL_UP_VL53L5CX_I2C)
        bDevicePresent := bDeviceFound := (idDevice() <> DVC_NOT_FOUND)
        if bShowDebug
            'debug(`snsLog '* Started' 10)
        if bDeviceFound
            isAlive()

PUB deviceID() : eDevice
    '' return indication (enum value) of if and which device we found on i2c bus
    eDevice := dvcI2CAddr

PUB stop()
    '' Stop our i2c bus use and float all pins
    ' no i2c_buss call needed, simply release all our pins
    if bPinsSetUp
        floatPins()
{
        if bShowDebug
            debug(`snsLog '* Stopped' 10)
'}
PUB begin()
'' yep, exrtacted from example code, ready our TOF Sensor
    pinl(pin_rst)    ' de-assert
    pinl(pin_lpn)    ' de-assert

PUB getRangingMode() : status, eRangingMode | bStatusOK

	status := VL53L5CX_STATUS_OK

	' status |= vl53l5cx_dci_read_data(p_dev, p_dev->temp_buffer, VL53L5CX_DCI_RANGING_MODE, 8)
    bStatusOK := readBytes(VL53L5CX_DCI_RANGING_MODE, 8, @tempBuffer)

	if (BYTE[@tempBuffer][1] == 1)
		eRangingMode := VL53L5CX_RANG_MODE_CONTINUOUS
	else
		eRangingMode := VL53L5CX_RANG_MODE_AUTONOMOUS


PUB setRangingMode(ranging_mode) : status | single_range, bStatusOK

    status := VL53L5CX_STATUS_OK
    single_range := 0

    ' status |= vl53l5cx_dci_read_data(p_dev, p_dev->temp_buffer, VL53L5CX_DCI_RANGING_MODE, 8)
    bStatusOK := readBytes(VL53L5CX_DCI_RANGING_MODE, 8, @tempBuffer)

    case ranging_mode
        VL53L5CX_RANG_MODE_CONTINUOUS:
            BYTE[@tempBuffer][1] := 1
            BYTE[@tempBuffer][3] := 3
            single_range := 0

        VL53L5CX_RANG_MODE_AUTONOMOUS:
            BYTE[@tempBuffer][1] := 3
            BYTE[@tempBuffer][3] := 2
            single_range := 1

        other:
            status := VL53L5CX_STATUS_INVALID_PARAM

    ' if request is valid, configure our device
    if status <> VL53L5CX_STATUS_INVALID_PARAM
        ' status |= vl53l5cx_dci_write_data(p_dev, p_dev->temp_buffer, VL53L5CX_DCI_RANGING_MODE, (uint16_t)8)
        bStatusOK := writeBytes(VL53L5CX_DCI_RANGING_MODE, @tempBuffer, 8)
        ' status |= vl53l5cx_dci_write_data(p_dev, (uint8_t *)&single_range, VL53L5CX_DCI_SINGLE_RANGE, (uint16_t)sizeof(single_range))
        ' FIXME: single_range is now compiler byte order but what does device need? VERIFY THIS!!!
        bStatusOK := writeBytes(VL53L5CX_DCI_SINGLE_RANGE, @single_range, 4)

PUB getResolution() : status, nResolution8
	status = VL53L5CX_STATUS_OK

	' status |= vl53l5cx_dci_read_data(p_dev, p_dev->temp_buffer, VL53L5CX_DCI_ZONE_CONFIG, 8)
    status |= readBytes(VL53L5CX_DCI_ZONE_CONFIG, 8, @tempBuffer)

	nResolution8 := BYTE[@tempBuffer][0] * BYTE[@tempBuffer][1] '  p_dev->temp_buffer[0x00] * p_dev->temp_buffer[0x01]

PUB startRanging() : status | nResolution8b, i, bhType, bhIdx, bhSize, logicalValue32b
    status := VL53L5CX_STATUS_OK

    ' load output[] buffer data
    LONG[@output][0] := startBh
    LONG[@output][1] := metaDataBh
    LONG[@output][2] := commonDataBh
    LONG[@output][3] := ambientRateBh
    LONG[@output][4] := spadCountBh
    LONG[@output][5] := nbTargetDetectedBh
    LONG[@output][6] := signalRateBh
    LONG[@output][7] := rangeSigmaMMBh
    LONG[@output][8] := distanceBh
    LONG[@output][9] := reflectanceBh
    LONG[@output][10] := targetStatusBh
    LONG[@output][11] := motionDetectBh

    status, nResolution8b := getResolution()   ' status |= vl53l5cx_get_resolution(p_dev, &resolution)
	dataReadSize := 0
	streamcount := 255   ' p_dev->streamcount := 255 Used by vl53l5cx_check_data_ready()

	' Enable/Disable selected outputs in the DAT { start ranging data } section
    '  (set bit for each section enabled)
    if ambientPerSpad
	    LONG[@output_bh_enable][0] += 8

    if nbSpadsEnabled
        LONG[@output_bh_enable][0] += 16

    if nbTargetDetected
        LONG[@output_bh_enable][0] += 32

    if signalPerSpad
        LONG[@output_bh_enable][0] += 64

    if rangeSigmaMM
        LONG[@output_bh_enable][0] += 128

    if distanceMM
        LONG[@output_bh_enable][0] += 256

    if reflectancePrcnt
        LONG[@output_bh_enable][0] += 512

    if targetStatus
        LONG[@output_bh_enable][0] += 1024

    if motionIndicator
        LONG[@output_bh_enable][0] += 2048

    ' NOTE: union interp:
    '   union Block_header {
    '   	uint32_t bytes;             ' bytes is the full long
    '   	struct {
    '   		uint32_t type : 4;      ' type is bits 31-28
    '   		uint32_t size : 12;     ' size is bits 27-16
    '   		uint32_t idx : 16;      ' type is bits 15-0
    '   	};
    '   };

	' Update data size
	'for (i := 0 i < (uint32_t)(sizeof(output) / sizeof(uint32_t)) i++)
    repeat i from 0 to (output_len / 4) - 1     ' output_len is 48 (12 longs, 4 bytes ea.)
		if ((output[i] == 0) || ((output_bh_enable[i / 32] & (1 << (i // 32))) == 0))
			next

        ' for each of the 12 longs that is (not zero, or block-bit is set) do
		' bh_ptr := (union Block_header *)&(output[i])    ' output[] is 12 longs
        '
        ' NOTE:     LOGICAL STORE (VALUE): $1234_5678 (bytes in register)
        '    while PHYSICAL STORE(IN-RAM): $7856_3412 (bytes in RAM)
        '
        ' each following line: load logical, mask it and shift it into place...
        ' - physical store: $7000_0000, logical store $0000_0070
        logicalValue32b := LONG[@output][i]
        bhType := (logicalValue32b & $0000_00f0) >> 4                                           ' build $0000_0007
        ' - physical store: $0856_0000, logical store $0000_5608
        bhIdx := (logicalValue32b & $0000_ff00 >> 8) | (logicalValue32b & $0000_000f) << 8      ' build $0000_0856
        ' - physical store: $0000_3412, logical store $1234_0000
        bhSize := (logicalValue32b & $ff00_0000) >> 24 | (logicalValue32b & $00ff_0000) >> 8    ' build $0000_3412
		if ((bhType >= $01) and (bhType < $0d))
			if ((bhIdx >= $54d0) and (bhIdx < ($54d0 + 960)))
				bhSize := nResolution8b
			else
				bhSize := (nResolution8b * VL53L5CX_NB_TGT_PER_ZONE)
            LONG[@output][i] &= !$0000_ff0f                 ' clear size field
            LONG[@output][i] |= ((bhSize & $0000_0f00) >> 8) | ((bhSize & $0000_00ff) << 8)     ' place new size value in field
			dataReadSize += bhType * bhSize
		else
			dataReadSize += bhSize
		dataReadSize += 4
	dataReadSize += 20

    ' code translation cross-check
    if dataReadSize > 255
        debug("startRanging() ERROR dataReadSize wont fit into byte!!")

	'status |= vl53l5cx_dci_write_data(p_dev, (uint8_t *)&(output), VL53L5CX_DCI_OUTPUT_LIST, (uint16_t)sizeof(output))
    status |= writeBytes(VL53L5CX_DCI_OUTPUT_LIST, @output, output_len)

	BYTE[@header_config][0] := dataReadSize
	BYTE[@header_config][1] := i + 1

	'status |= vl53l5cx_dci_write_data(p_dev, (uint8_t *)&(header_config), VL53L5CX_DCI_OUTPUT_CONFIG, (uint16_t)sizeof(header_config))
    status |= writeBytes(VL53L5CX_DCI_OUTPUT_CONFIG, @header_config, header_config_len)

	'status |= vl53l5cx_dci_write_data(p_dev, (uint8_t *)&(output_bh_enable), VL53L5CX_DCI_OUTPUT_ENABLES, (uint16_t)sizeof(output_bh_enable))
    status |= writeBytes(VL53L5CX_DCI_OUTPUT_ENABLES, @output_bh_enable, output_bh_en_len)

	' Start xshut bypass (interrupt mode)
	status |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)      ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x00)
	status |= writeByte($09, $05)                                           ' status |= WrByte(&(p_dev->platform), 0x09, 0x05)
	status |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_RUN)         ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x02)

	' Start ranging session
	'status |= WrMulti(&(p_dev->platform), VL53L5CX_UI_CMD_END - (uint16_t)(4 - 1), (uint8_t *)cmd, sizeof(cmd))
    status |= writeBytes(VL53L5CX_UI_CMD_END - (4 - 1), @cmd, cmd_len)
	'status |= _vl53l5cx_poll_for_answer(p_dev, 4, 1, VL53L5CX_UI_CMD_STATUS, 0xff, 0x03)
    status |= pollForAnswer(4, 1, VL53L5CX_UI_CMD_STATUS, $FF, 3)


PUB setI2CAddress(i2cAddress) : eDvcStatus | bStatusOK

    eDvcStatus := VL53L5CX_STATUS_OK

    bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)          ' |= WrByte(&(p_dev->platform), 0x7fff, 0x00)
    bStatusOK |= writeByte(VL53L5CX_REG_DVC_ADDR, i2cAddress >> 1)                 ' |= WrByte(&(p_dev->platform), 0x4, (uint8_t)(i2c_address >> 1))
                                                                                ' p_dev->platform.address = i2c_address
    bStatusOK |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_RUN)             ' |= WrByte(&(p_dev->platform), 0x7fff, 0x02)
    if not bStatusOK
        eDvcStatus := VL53L5CX_STATUS_ERROR

    dvcI2CAddr := i2cAddress

PUB isAlive() : eDvcStatus, bIsAlive | device_id, revision_id, bStatusOK, bTempStatusOK

    eDvcStatus := VL53L5CX_STATUS_OK

    bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)               ' |= WrByte(&(p_dev->platform), 0x7fff, 0x00)
    bTempStatusOK, device_id := readByte(VL53L5CX_REG_DVC_ID)                           ' |= RdByte(&(p_dev->platform), 0, &device_id)
    bStatusOK |= bTempStatusOK
    bTempStatusOK, revision_id := readByte(VL53L5CX_REG_REV_ID)                         ' |= RdByte(&(p_dev->platform), 1, &revision_id)
    bStatusOK |= bTempStatusOK
    bStatusOK |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_RUN)                  ' |= WrByte(&(p_dev->platform), 0x7fff, 0x02)
    if not bStatusOK
        eDvcStatus := VL53L5CX_STATUS_ERROR

    if ((device_id == $F0) and (revision_id == $02))
        bIsAlive := TRUE
        debug("TOF: is alive!")
    else
        bIsAlive := FALSE

PUB getIntPinState() : bPinState | rawPin
    '' Return interpreted value of Interrupt pin where 1 = TRUE, 0 = FALSE
    rawPin := pinr(pin_int)
    bPinState := (rawPin == 0) ? false : true
    'if bShowDebug
        'debug(`snsLog ' * getIntPinState() PinRaw=`(rawPin), state=`(bPinState)' 10)

PUB initSensor()
    ' turn off: vl53l5cx_off()
    ' turn on: vl53l5cx_on()
    ' set desired I2C address: vl53l5cx_set_i2c_address(addr)
    '   return VL53L5CX_STATUS_ERROR if failed to set
    ' see if alive: vl53l5cx_is_alive(&isAlive)
    '   return VL53L5CX_STATUS_ERROR if not
    ' init device: vl53l5cx_init()
    '   return VL53L5CX_STATUS_ERROR if failed to init
    ' return VL53L5CX_STATUS_OK

CON '  ---- PRIVATE (Utility) Methods ----

PRI setupPins(pinINT, pinRST, pinSDA, pinSCL, pinLPN, pinPWREN) : ok
    ' Configure pin numbers if not already
    '   return T/F where T means SUCCESS and F means FAILED - bad basepin value
    ok := true

    pin_scl := pinSCL
    pin_sda := pinSDA
    pin_int := pinINT

    ' I2C_RST: I2C interface reset pin, active high. Toggle this pin from 0 to 1, then back to 0 to reset the I2C
    pin_rst := pinRST

    ' LPn: Comms enable. Drive this pin to logic 0 to disable the I2C comms when the device is in
    '  LP mode. Drive this pin to logic 1 to enable I2C comms in LP mode. Typically used when
    '  it is required to change the I2C adress in multidevice systems.
    pin_lpn := pinLPN
      '
    pin_pwren := pinPWREN

    ' float our inputs
    floatPins()

    ' enable 5v to 3.3v power supply
    pinh(pin_pwren)             ' assert pwr enable

    ' condition the chip drive
    pinh(pin_lpn)               ' assert LPn (enable device selection)

    resetI2C()

PRI resetI2C()
' reset the I2C interface controller of the vl53l5cx
    pinl(pin_rst)               ' De-assert reset
    waitus(10)
    pinh(pin_rst)               ' Assert reset  (reset the I2C I/F)
    waitus(10)
    pinl(pin_rst)               ' De-assert reset
    waitus(10)

PRI resetSensor()
' reset vl53l5cx sensor
    pinl(pin_lpn)               ' De-assert device enable
    waitus(10)
    pinh(pin_lpn)               ' Assert device enable
    waitus(10)

PRI floatPins()
    ' pre-condition the click I/O pins
    pinf(pin_rst)    ' de-assert
    pinf(pin_int)    ' de-assert
    pinf(pin_scl)    ' de-assert
    pinf(pin_sda)    ' de-assert
    pinf(pin_lpn)    ' de-assert
    pinf(pin_pwren)  ' de-assert

PRI idDevice() : eDevice | bFoundAddr0, bFoundAddr1
    ' Identify the address our device is at on the i2c bus
    floatPins()
        ' enable 5v to 3.3v power supply
    pinh(pin_pwren)             ' assert pwr enable
    waitus(2)

    ' condition the chip drive
    pinh(pin_lpn)               ' assert LPn (enable device selection)

    bFoundAddr0 := bFoundAddr1 := false
    if(i2c_bus.present((VL53L5CX_I2C_ADDR_1 & $fe | I2C_MODE_WRITE)))
        bFoundAddr1 := true
    else
        if(i2c_bus.present((VL53L5CX_I2C_ADDR_0 & $fe | I2C_MODE_WRITE)))
            bFoundAddr0 := true
    i2c_bus.stop()

    dvcI2CAddr := DVC_NOT_FOUND
    eDevice := DVC_NOT_FOUND
    if(!bFoundAddr0 and bFoundAddr1)
        eDevice := DVC_ADDR1
        dvcI2CAddr := VL53L5CX_I2C_ADDR_1 >> 1
    elseif(bFoundAddr0 and !bFoundAddr1)
        eDevice := DVC_ADDR0
        dvcI2CAddr := VL53L5CX_I2C_ADDR_0 >> 1
{
    if (bFoundAddr0 or bFoundAddr1)
        if bShowDebug
            debug(`snsLog ' * idDevice() found Addr`(dvcI2CAddr - 1)' 10)
    else
        if bShowDebug
            debug("* idDevice() NOT found")
'}

PRI vl53l5cx_init() : eDvcStatus | pipe_ctrl, single_range, bStatusOK, bTempStatusOK, tmp

	' uint8_t tmp, status = VL53L5CX_STATUS_OK
    eDvcStatus := VL53L5CX_STATUS_OK

	' uint8_t pipe_ctrl[] = {VL53L5CX_NB_TGT_PER_ZONE, 0x00, 0x01, 0x00}
    pipe_ctrl.byte[0] := VL53L5CX_NB_TGT_PER_ZONE
    pipe_ctrl.byte[1] := 0
    pipe_ctrl.byte[2] := 1
    pipe_ctrl.byte[3] := 0

	single_range := 1

	' SW reboot sequence

    bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)   ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x00)
	bStatusOK |= writeByte($0009, 4)                                        ' status |= WrByte(&(p_dev->platform), 0x0009, 0x04)
	bStatusOK |= writeByte($000F, $40)                                      ' status |= WrByte(&(p_dev->platform), 0x000F, 0x40)
	bStatusOK |= writeByte($000A, 3)                                        ' status |= WrByte(&(p_dev->platform), 0x000A, 0x03)
    bTempStatusOK, tmp := readByte(VL53L5CX_REG_CONTROL)                    ' status |= RdByte(&(p_dev->platform), 0x7fff, &tmp)
    bStatusOK |= bTempStatusOK
	bStatusOK |= writeByte($000C, 1)                                        ' status |= WrByte(&(p_dev->platform), 0x000C, 0x01)
	bStatusOK |= writeByte($0101, 0)                                        ' status |= WrByte(&(p_dev->platform), 0x0101, 0x00)
	bStatusOK |= writeByte($0102, 0)                                        ' status |= WrByte(&(p_dev->platform), 0x0102, 0x00)
	bStatusOK |= writeByte($010A, 1)                                        ' status |= WrByte(&(p_dev->platform), 0x010A, 0x01)
	bStatusOK |= writeByte($4002, 1)                                        ' status |= WrByte(&(p_dev->platform), 0x4002, 0x01)
	bStatusOK |= writeByte($4002, 0)                                        ' status |= WrByte(&(p_dev->platform), 0x4002, 0x00)
	bStatusOK |= writeByte($010A, 3)                                        ' status |= WrByte(&(p_dev->platform), 0x010A, 0x03)
	bStatusOK |= writeByte($0103, 1)                                        ' status |= WrByte(&(p_dev->platform), 0x0103, 0x01)
	bStatusOK |= writeByte($000C, 0)                                        ' status |= WrByte(&(p_dev->platform), 0x000C, 0x00)
	bStatusOK |= writeByte($000A, 3)                                        ' status |= WrByte(&(p_dev->platform), 0x000F, 0x43)
	waitus(1)                                                               ' status |= WaitMs(&(p_dev->platform), 1)

	bStatusOK |= writeByte($000F, $40)                                      ' status |= WrByte(&(p_dev->platform), 0x000F, 0x40)
	bStatusOK |= writeByte($000A, 1)                                        ' status |= WrByte(&(p_dev->platform), 0x000A, 0x01)
	waitus(100)                                                             ' status |= WaitMs(&(p_dev->platform), 100)

	' Wait for sensor booted (several ms required to get sensor ready )
	bStatusOK |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)   ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x00)
    bStatusOK |= pollForAnswer(1, 0, $06, $FF, 1)                           ' status |= _vl53l5cx_poll_for_answer(p_dev, 1, 0, 0x06, 0xff, 1)

	bStatusOK |= writeByte($000E, 1)                                        ' status |= WrByte(&(p_dev->platform), 0x000E, 0x01)
	bStatusOK |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_RUN)      ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x02)

	' Enable FW access
	bStatusOK |= writeByte($0003, $0D)                                      ' status |= WrByte(&(p_dev->platform), 0x03, 0x0D)
	bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_FW)       ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x01)
    bStatusOK |= pollForAnswer(1, 0, $21, $10, $10)                         ' status |= _vl53l5cx_poll_for_answer(p_dev, 1, 0, 0x21, 0x10, 0x10)
	bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)   ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x00)

	' Enable host access to GO1
	bStatusOK := writeByte($0C, 1)                                          ' status |= WrByte(&(p_dev->platform), 0x0C, 0x01)

	' Power ON status
	bStatusOK |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)   ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x00)
	bStatusOK |= writeByte($101, 0)                                         ' status |= WrByte(&(p_dev->platform), 0x101, 0x00)
	bStatusOK |= writeByte($102, 0)                                         ' status |= WrByte(&(p_dev->platform), 0x102, 0x00)
	bStatusOK |= writeByte($10A, 1)                                         ' status |= WrByte(&(p_dev->platform), 0x010A, 0x01)
	bStatusOK |= writeByte($4002, 1)                                        ' status |= WrByte(&(p_dev->platform), 0x4002, 0x01)
	bStatusOK |= writeByte($4002, 0)                                        ' status |= WrByte(&(p_dev->platform), 0x4002, 0x00)
	bStatusOK |= writeByte($10A, 3)                                         ' status |= WrByte(&(p_dev->platform), 0x010A, 0x03)
	bStatusOK |= writeByte($103, 1)                                         ' status |= WrByte(&(p_dev->platform), 0x103, 0x01)
	bStatusOK |= writeByte($400F, 0)                                        ' status |= WrByte(&(p_dev->platform), 0x400F, 0x00)
	bStatusOK |= writeByte($21A, $43)                                       ' status |= WrByte(&(p_dev->platform), 0x21A, 0x43)
	bStatusOK |= writeByte($21A, 3)                                         ' status |= WrByte(&(p_dev->platform), 0x21A, 0x03)
	bStatusOK |= writeByte($21A, 1)                                         ' status |= WrByte(&(p_dev->platform), 0x21A, 0x01)
	bStatusOK |= writeByte($21A, 0)                                         ' status |= WrByte(&(p_dev->platform), 0x21A, 0x00)
	bStatusOK |= writeByte($219, 0)                                         ' status |= WrByte(&(p_dev->platform), 0x219, 0x00)
	bStatusOK |= writeByte($21B, 0)                                         ' status |= WrByte(&(p_dev->platform), 0x21B, 0x00)

	' Wake up MCU
	bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)   ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x00)
	bStatusOK |= writeByte($000C, 0)                                        ' status |= WrByte(&(p_dev->platform), 0x000C, 0x00)
	bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_FW)       ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x01)
	bStatusOK |= writeByte($0020, 7)                                        ' status |= WrByte(&(p_dev->platform), 0x0020, 0x07)
	bStatusOK |= writeByte($0020, 6)                                        ' status |= WrByte(&(p_dev->platform), $0020, 0x06)
	' Download FW into VL53L5
    bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_FWBANK0)  ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x09)
	bStatusOK |= writeBytes(0, @BYTE[@VL53L5CX_FIRMWARE][0], $8000)         ' status |= WrMulti(&(p_dev->platform), 0, (uint8_t *) &VL53L5CX_FIRMWARE[0], 0x8000)
	bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_FWBANK1)  ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x0a)
	bStatusOK |= writeBytes(0, @BYTE[@VL53L5CX_FIRMWARE][$8000], $8000)     ' status |= WrMulti(&(p_dev->platform), 0, (uint8_t *) & VL53L5CX_FIRMWARE[0x8000], 0x8000)
	bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_FWBANK2)  ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x0b)
	bStatusOK |= writeBytes(0, @BYTE[@VL53L5CX_FIRMWARE][$10000], $5000)    ' status |= WrMulti(&(p_dev->platform), 0, (uint8_t *) & VL53L5CX_FIRMWARE[0x10000], 0x5000)
	bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_FW)       ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x01)

	' Check if FW correctly downloaded
	bStatusOK |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_RUN)      ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x02)
	bStatusOK |= writeByte($03, $0D)                                        ' status |= WrByte(&(p_dev->platform), 0x03, 0x0D)
	bStatusOK |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_FW)       ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x01)
	bStatusOK |= pollForAnswer(1, 0, $21, $10, $10)                         ' status |= _vl53l5cx_poll_for_answer(p_dev, 1, 0, 0x21, 0x10, 0x10) //0x10
	bStatusOK |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)   ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x00)
	bStatusOK |= writeByte($0C, 1)                                          ' status |= WrByte(&(p_dev->platform), 0x0C, 0x01)

	' Reset MCU and wait boot
	bStatusOK := writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_CONFIG)   ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x00)
	bStatusOK |= writeByte($114, 0)                                         ' status |= WrByte(&(p_dev->platform), 0x114, 0x00)
	bStatusOK |= writeByte($115, 0)                                         ' status |= WrByte(&(p_dev->platform), 0x115, 0x00)
	bStatusOK |= writeByte($116, 2)                                         ' status |= WrByte(&(p_dev->platform), 0x116, 0x42)
	bStatusOK |= writeByte($117, 0)                                         ' status |= WrByte(&(p_dev->platform), 0x117, 0x00)
	bStatusOK |= writeByte($0B, 0)                                          ' status |= WrByte(&(p_dev->platform), 0x0B, 0x00)
	bStatusOK |= writeByte($0C, 0)                                          ' status |= WrByte(&(p_dev->platform), 0x0C, 0x00)
	bStatusOK |= writeByte($0B, 1)                                          ' status |= WrByte(&(p_dev->platform), 0x0B, 0x01)
	bStatusOK |= pollForAnswer(1, 0, $06, $ff, $00)                         ' status |= _vl53l5cx_poll_for_answer(p_dev, 1, 0, 0x06, 0xff, 0x00)
	bStatusOK |= writeByte(VL53L5CX_REG_CONTROL, VL53L5CX_VAL_CTL_RUN)      ' status |= WrByte(&(p_dev->platform), 0x7fff, 0x02)

	' Get offset NVM data and store them into the offset buffer
	'status |= WrMulti(&(p_dev->platform), 0x2fd8, (uint8_t *)VL53L5CX_GET_NVM_CMD, sizeof(VL53L5CX_GET_NVM_CMD))
    bStatusOK |= writeBytes($2fd8, @VL53L5CX_GET_NVM_CMD, VL53L5CX_GET_NVM_CMD_LEN)

	'status |= _vl53l5cx_poll_for_answer(p_dev, 4, 0, VL53L5CX_UI_CMD_STATUS, 0xff, 2)
    bStatusOK |= pollForAnswer(4, 0, VL53L5CX_UI_CMD_STATUS, $FF, 2)

	' status |= RdMulti(&(p_dev->platform), VL53L5CX_UI_CMD_START, p_dev->temp_buffer, VL53L5CX_NVM_DATA_SIZE)
    bStatusOK |= readBytes(VL53L5CX_UI_CMD_START, VL53L5CX_NVM_DATA_SIZE, @tempBuffer)

	' (void)memcpy(p_dev->offset_data, p_dev->temp_buffer, VL53L5CX_OFFSET_BUFFER_SIZE)
    ' NOTE not copying before send... new method does its own copy
	bStatusOK |= sendOffsetData(VL53L5CX_RESOLUTION_4X4, @tempBuffer, VL53L5CX_OFFSET_BUFFER_SIZE)

	' Set default Xtalk shape. Send Xtalk to sensor
	' (void)memcpy(p_dev->xtalk_data, (uint8_t *)VL53L5CX_DEFAULT_XTALK, VL53L5CX_XTALK_BUFFER_SIZE)
    ' NOTE not copying before send... new method does its own copy
	bStatusOK |= sendXtalkData(VL53L5CX_RESOLUTION_4X4, @VL53L5CX_DEFAULT_XTALK, VL53L5CX_XTALK_BUFFER_SIZE)

	' Send default configuration to VL53L5CX firmware
	' status |= WrMulti(&(p_dev->platform), 0x2c34, (uint8_t *)VL53L5CX_DEFAULT_CONFIGURATION, sizeof(VL53L5CX_DEFAULT_CONFIGURATION))
    bStatusOK |= writeBytes($2c34, @VL53L5CX_DEFAULT_CONFIGURATION, VL53L5CX_DEFAULT_CONFIG_LEN)

	' status |= _vl53l5cx_poll_for_answer(p_dev, 4, 1, VL53L5CX_UI_CMD_STATUS, 0xff, 0x03)
    bStatusOK |= pollForAnswer(4, 1, VL53L5CX_UI_CMD_STATUS, $FF, 3)

	' status |= vl53l5cx_dci_write_data(p_dev, (uint8_t *)&pipe_ctrl, VL53L5CX_DCI_PIPE_CONTROL, (uint16_t)sizeof(pipe_ctrl))
    bStatusOK |= writeBytes(VL53L5CX_DCI_PIPE_CONTROL, @pipe_ctrl, 4)

    if VL53L5CX_NB_TGT_PER_ZONE <> 1
        tmp := VL53L5CX_NB_TGT_PER_ZONE
        bStatusOK |= dciReplaceData(@tempBuffer, VL53L5CX_DCI_FW_NB_TARGET, 16, @tmp.byte[0], 1, $0C)

	' status |= vl53l5cx_dci_write_data(p_dev, (uint8_t *)&single_range, VL53L5CX_DCI_SINGLE_RANGE, (uint16_t)sizeof(single_range))
    bStatusOK |= writeBytes(VL53L5CX_DCI_SINGLE_RANGE, @single_range, 4)   ' write 32-bit value




CON { Device Registers - best we can tell }

    VL53L5CX_REG_CONTROL = $7fff
    VL53L5CX_VAL_CTL_CONFIG = $00
    VL53L5CX_VAL_CTL_FW     = $01
    VL53L5CX_VAL_CTL_RUN    = $02
    VL53L5CX_VAL_CTL_FWBANK0    = $09
    VL53L5CX_VAL_CTL_FWBANK1    = $0A
    VL53L5CX_VAL_CTL_FWBANK2    = $0B

    VL53L5CX_REG_DVC_ID = $0000
    VL53L5CX_REG_REV_ID = $0001

    VL53L5CX_REG_DVC_ADDR = $0004

    TMP_SIZE_IN_BYTES = 30

CON { fixed driver values }

    VL53L5CX_T1_FW_NBTAR_RANGING = 2
    VL53L5CX_FW_NBTAR_RANGING = VL53L5CX_NB_TGT_PER_ZONE

    ' Inner Macro for API. Not for user, only for development.

    VL53L5CX_NVM_DATA_SIZE		            = 492
    VL53L5CX_CONFIGURATION_SIZE	            = 972
    VL53L5CX_OFFSET_BUFFER_SIZE	            = 488
    VL53L5CX_XTALK_BUFFER_SIZE	            = 776

    VL53L5CX_DCI_ZONE_CONFIG	            = $5450
    VL53L5CX_DCI_FREQ_HZ		            = $5458
    VL53L5CX_DCI_INT_TIME		            = $545C
    VL53L5CX_DCI_FW_NB_TARGET	            = $5478
    VL53L5CX_DCI_RANGING_MODE	            = $AD30
    VL53L5CX_DCI_DSS_CONFIG		            = $AD38
    VL53L5CX_DCI_TGT_ORDER	                = $AE64
    VL53L5CX_DCI_SHARPENER		            = $AED8
    VL53L5CX_DCI_MOTN_DETECTOR_CFG        = $BFAC
    VL53L5CX_DCI_SINGLE_RANGE	            = $CD5C
    VL53L5CX_DCI_OUTPUT_CONFIG	            = $CD60
    VL53L5CX_DCI_OUTPUT_ENABLES	            = $CD68
    VL53L5CX_DCI_OUTPUT_LIST	            = $CD78
    VL53L5CX_DCI_PIPE_CONTROL	            = $CF78

    VL53L5CX_UI_CMD_STATUS		            = $2C00
    VL53L5CX_UI_CMD_START		            = $2C04
    VL53L5CX_UI_CMD_END		                = $2FFF

' Macro VL53L5CX_TEMP_BUFFER_SIZE can be used to know the size of
'  the temporary buffer. The minimum size is 1024, and the maximum depends of
'  the output configuration.

'#if VL53L5CX_MAX_RESULTS_SIZE < 1024U
'#define VL53L5CX_TEMP_BUFFER_SIZE ((uint32_t) 4096U)
'#else
'#define VL53L5CX_TEMP_BUFFER_SIZE ((uint32_t) VL53L5CX_MAX_RESULTS_SIZE)
'#endif

    VL53L5CX_TEMP_BUFFER_SIZE = 4096

CON { driver sizes }

    OVERALL_BUFFER_SIZE_BYTES = (VL53L5CX_XTALK_BUFFER_SIZE > VL53L5CX_OFFSET_BUFFER_SIZE) ? VL53L5CX_XTALK_BUFFER_SIZE : VL53L5CX_OFFSET_BUFFER_SIZE
    SIGNAL_GRID_SIZE_BYTES = 64
    RANGE_GRID_SIZE_BYTES = 64

DAT { start ranging data }

    header_config       BYTE    0[2]
    header_config_end
    header_config_len   LONG    @header_config_end - @header_config     ' number of header_config[] bytes

    cmd                 BYTE    $00, $03, $00, $00                      ' uint8_t cmd[] := {0x00, 0x03, 0x00, 0x00}
    cmd_end
    cmd_len             LONG    @cmd_end - @cmd                         ' number of cmd[] bytes

    output_bh_enable    LONG    $00000007, $00000000, $00000000, $C0000000  ' Enable mandatory output (meta and common data)
    output_bh_en_end
    output_bh_en_len    LONG    @output_bh_en_end - @output_bh_enable   ' number of output_bh_enable[] bytes

	' set addresses of possible output
    output              LONG    0[12]
    output_end
    output_len          LONG    @output_end - @output                   ' number of output[] bytes


' ----------------------------------------------------------------------------------
' The bytes below (T/F) are used to configure the sensor output. User can
'   set to FALSE if he wants to disable selected output, in order to reduce
'   I2C access.  These are enabled by default.

    ' driver tunables: (T/F where F is disabled)
    ambientPerSpad      BYTE    TRUE    ' define VL53L5CX_DISABLE_AMBIENT_PER_SPAD
    nbSpadsEnabled      BYTE    TRUE    ' define VL53L5CX_DISABLE_NB_SPADS_ENABLED
    nbTargetDetected    BYTE    TRUE    ' define VL53L5CX_DISABLE_NB_TARGET_DETECTED
    signalPerSpad       BYTE    TRUE    ' define VL53L5CX_DISABLE_SIGNAL_PER_SPAD
    rangeSigmaMM        BYTE    TRUE    ' define VL53L5CX_DISABLE_RANGE_SIGMA_MM
    distanceMM          BYTE    TRUE    ' define VL53L5CX_DISABLE_DISTANCE_MM
    reflectancePrcnt    BYTE    TRUE    ' define VL53L5CX_DISABLE_REFLECTANCE_PERCENT
    targetStatus        BYTE    TRUE    ' define VL53L5CX_DISABLE_TARGET_STATUS
    motionIndicator     BYTE    TRUE    ' define VL53L5CX_DISABLE_MOTION_INDICATOR
' ----------------------------------------------------------------------------------

    ambSize             LONG    0
    spadSize            LONG    0
    ntarSize            LONG    0
    spsSize             LONG    0
    sigrSize            LONG    0
    distSize            LONG    0
    rflestSize          LONG    0
    staSize             LONG    0
    motSize             LONG    0

VAR { driver uninitialized data }

    ' NOTE initDriver() must be called to init these variables before use!
        ' 32-bit values
    LONG    startBh
    LONG    metaDataBh
    LONG    commonDataBh
    LONG    ambientRateBh
    LONG    spadCountBh
    LONG    nbTargetDetectedBh
    LONG    signalRateBh
    LONG    rangeSigmaMMBh
    LONG    distanceBh
    LONG    reflectanceBh
    LONG    targetStatusBh
    LONG    motionDetectBh
        ' 16-bit values
    WORD    metaDataIdx
    WORD    spadCountIdx
    WORD    ambientRateIdx
    WORD    nbTargetDetectIdx
    WORD    signalRateIdx
    WORD    rangeSigmaMMIdx
    WORD    distanceIdx
    WORD    reflectancePrcntIdx
    WORD    targetStatusIdx
    WORD    motionDetectIdx

' maxResultsSize indicates the maximum size used by output through I2C.
    LONG    maxResultsSize      ' was VL53L5CX_MAX_RESULTS_SIZE

 ' Structure VL53L5CX_Configuration contains the sensor configuration.
'   User MUST not manually change these fields, except for the sensor address.

' -----------------------------------
' typedef struct VL53L5CX_Configuration
' -----------------------------------
	' Platform, filled by customer into the 'platform.h' file */
	'    VL53L5CX_Platform	platform
	' Results streamcount, value auto-incremented at each range */
	BYTE		    streamcount
	' Size of data read though I2C */
	LONG	        dataReadSize
	' Address of default configuration buffer */
	LONG	        pDefaultConfigurationBytes
	' Address of default Xtalk buffer */
	LONG		    pDefaultXtalkBytes
	' Offset buffer */
	BYTE		    offset_data[VL53L5CX_OFFSET_BUFFER_SIZE]
	' Xtalk buffer */
	BYTE		    xtalk_data[VL53L5CX_XTALK_BUFFER_SIZE]
	' Temporary buffer used for internal driver processing */
	BYTE	        temp_buffer[VL53L5CX_TEMP_BUFFER_SIZE]
' -----------------------------------

    BYTE            tempBuffer[TMP_SIZE_IN_BYTES]   ' FIXME: merge this and above one


CON '  --- Device Literals for register load ---

    ' if TARGET_PER_ZONE == 1
    ' 32-bit values
    VL53L5CX_T1_START_BH			        = $0000000D
    VL53L5CX_T1_METADATA_BH			        = $54B400C0
    VL53L5CX_T1_COMMONDATA_BH			    = $54C00040
    VL53L5CX_T1_AMBIENT_RATE_BH		        = $54D00104
    VL53L5CX_T1_SPAD_COUNT_BH			    = $55D00404
    VL53L5CX_T1_NB_TGT_DTEKT_BH	            = $CF7C0401
    VL53L5CX_T1_SIGNAL_RATE_BH			    = $CFBC0404
    VL53L5CX_T1_RNG_SIGMA_MM_BH		        = $D2BC0402
    VL53L5CX_T1_DISTANCE_BH			        = $D33C0402
    VL53L5CX_T1_RFLCTNC_BH			        = $D43C0401
    VL53L5CX_T1_TGT_STATUS_BH		        = $D47C0401
    VL53L5CX_T1_MOTN_DTEKT_BH		        = $CC5008C0

    ' 16-bit values
    VL53L5CX_T1_METADATA_IDX			    = $54B4
    VL53L5CX_T1_SPAD_COUNT_IDX			    = $55D0
    VL53L5CX_T1_AMBIENT_RATE_IDX		    = $54D0
    VL53L5CX_T1_NB_TGT_DTEKT_IDX	        = $CF7C
    VL53L5CX_T1_SIGNAL_RATE_IDX		        = $CFBC
    VL53L5CX_T1_RNG_SIGMA_MM_IDX		    = $D2BC
    VL53L5CX_T1_DISTANCE_IDX			    = $D33C
    VL53L5CX_T1_RFLCTNC_EST_PC_IDX	        = $D43C
    VL53L5CX_T1_TGT_STATUS_IDX		        = $D47C
    VL53L5CX_T1_MOTN_DETEC_IDX		        = $CC50

    ' (else) if Target Per Zone <> 1
    ' 32-bit values
    VL53L5CX_START_BH			            = $0000000D
    VL53L5CX_METADATA_BH			        = $54B400C0
    VL53L5CX_COMMONDATA_BH			        = $54C00040
    VL53L5CX_AMBIENT_RATE_BH		        = $54D00104
    VL53L5CX_NB_TGT_DTEKT_BH		        = $57D00401
    VL53L5CX_SPAD_COUNT_BH			        = $55D00404
    VL53L5CX_SIGNAL_RATE_BH			        = $58900404
    VL53L5CX_RNG_SIGMA_MM_BH		        = $64900402
    VL53L5CX_DISTANCE_BH			        = $66900402
    VL53L5CX_RFLCTNC_BH			            = $6A900401
    VL53L5CX_TGT_STATUS_BH		            = $6B900401
    VL53L5CX_MOTN_DTEKT_BH		            = $CC5008C0

    ' 16-bit values
    VL53L5CX_METADATA_IDX			        = $54B4
    VL53L5CX_SPAD_COUNT_IDX			        = $55D0
    VL53L5CX_AMBIENT_RATE_IDX		        = $54D0
    VL53L5CX_NB_TGT_DTEKT_IDX		        = $57D0
    VL53L5CX_SIGNAL_RATE_IDX		        = $5890
    VL53L5CX_RNG_SIGMA_MM_IDX		        = $6490
    VL53L5CX_DISTANCE_IDX			        = $6690
    VL53L5CX_RFLCTNC_EST_PC_IDX		        = $6A90
    VL53L5CX_TGT_STATUS_IDX		            = $6B90
    VL53L5CX_MOTN_DETEC_IDX		            = $CC50

PRI initDriver()
' initialize our variables based upon number targets / zone compile value
    if VL53L5CX_NB_TGT_PER_ZONE == 1
        ' 32-bit values
        startBh                 := VL53L5CX_T1_START_BH
        metaDataBh              := VL53L5CX_T1_METADATA_BH
        commonDataBh            := VL53L5CX_T1_COMMONDATA_BH
        ambientRateBh           := VL53L5CX_T1_AMBIENT_RATE_BH
        spadCountBh             := VL53L5CX_T1_SPAD_COUNT_BH
        nbTargetDetectedBh      := VL53L5CX_T1_NB_TGT_DTEKT_BH
        signalRateBh            := VL53L5CX_T1_SIGNAL_RATE_BH
        rangeSigmaMMBh          := VL53L5CX_T1_RNG_SIGMA_MM_BH
        distanceBh              := VL53L5CX_T1_DISTANCE_BH
        reflectanceBh           := VL53L5CX_T1_RFLCTNC_BH
        targetStatusBh          := VL53L5CX_T1_TGT_STATUS_BH
        motionDetectBh          := VL53L5CX_T1_MOTN_DTEKT_BH
        ' 16-bit values
        metaDataIdx             := VL53L5CX_T1_METADATA_IDX
        spadCountIdx            := VL53L5CX_T1_SPAD_COUNT_IDX
        ambientRateIdx          := VL53L5CX_T1_AMBIENT_RATE_IDX
        nbTargetDetectIdx       := VL53L5CX_T1_NB_TGT_DTEKT_IDX
        signalRateIdx           := VL53L5CX_T1_SIGNAL_RATE_IDX
        rangeSigmaMMIdx         := VL53L5CX_T1_RNG_SIGMA_MM_IDX
        distanceIdx             := VL53L5CX_T1_DISTANCE_IDX
        reflectancePrcntIdx     := VL53L5CX_T1_RFLCTNC_EST_PC_IDX
        targetStatusIdx         := VL53L5CX_T1_TGT_STATUS_IDX
        motionDetectIdx         := VL53L5CX_T1_MOTN_DETEC_IDX

    else    ' (else) if Target Per Zone <> 1
        ' 32-bit values
        startBh                 := VL53L5CX_START_BH
        metaDataBh              := VL53L5CX_METADATA_BH
        commonDataBh            := VL53L5CX_COMMONDATA_BH
        ambientRateBh           := VL53L5CX_AMBIENT_RATE_BH
        spadCountBh             := VL53L5CX_SPAD_COUNT_BH
        nbTargetDetectedBh      := VL53L5CX_NB_TGT_DTEKT_BH
        signalRateBh            := VL53L5CX_SIGNAL_RATE_BH
        rangeSigmaMMBh          := VL53L5CX_RNG_SIGMA_MM_BH
        distanceBh              := VL53L5CX_DISTANCE_BH
        reflectanceBh           := VL53L5CX_RFLCTNC_BH
        targetStatusBh          := VL53L5CX_TGT_STATUS_BH
        motionDetectBh          := VL53L5CX_MOTN_DTEKT_BH
        ' 16-bit values
        metaDataIdx             := VL53L5CX_METADATA_IDX
        spadCountIdx            := VL53L5CX_SPAD_COUNT_IDX
        ambientRateIdx          := VL53L5CX_AMBIENT_RATE_IDX
        nbTargetDetectIdx       := VL53L5CX_NB_TGT_DTEKT_IDX
        signalRateIdx           := VL53L5CX_SIGNAL_RATE_IDX
        rangeSigmaMMIdx         := VL53L5CX_RNG_SIGMA_MM_IDX
        distanceIdx             := VL53L5CX_DISTANCE_IDX
        reflectancePrcntIdx     := VL53L5CX_RFLCTNC_EST_PC_IDX
        targetStatusIdx         := VL53L5CX_TGT_STATUS_IDX
        motionDetectIdx         := VL53L5CX_MOTN_DETEC_IDX

    if ambientPerSpad
        ambSize	:= 260

    if nbSpadsEnabled
        spadSize := 260

    if nbTargetDetected
        ntarSize := 68

    if signalPerSpad
        spsSize := ((256 * VL53L5CX_NB_TGT_PER_ZONE) + 4)

    if rangeSigmaMM
        sigrSize := ((128 * VL53L5CX_NB_TGT_PER_ZONE) + 4)

    if distanceMM
        distSize := ((128 * VL53L5CX_NB_TGT_PER_ZONE) + 4)

    if reflectancePrcnt
        rflestSize := ((64 *VL53L5CX_NB_TGT_PER_ZONE) + 4)

    if targetStatus
        staSize := ((64  *VL53L5CX_NB_TGT_PER_ZONE) + 4)

    if motionIndicator
        motSize := 144

    ' maxResultsSize indicates the maximum size used by output through I2C.
    '  Value 40 corresponds to headers + meta-data + common-data and 8 corresponds to the footer.
    maxResultsSize := (40 + ambSize + spadSize + ntarSize + spsSize + sigrSize + distSize + rflestSize + staSize + motSize + 8)

    if maxResultsSize > VL53L5CX_TEMP_BUFFER_SIZE
        debug("initDriver() ERROR need buffer: ", udec_(maxResultsSize), ", which exceeds allocated: ", udec_(VL53L5CX_TEMP_BUFFER_SIZE))
PRI pollForAnswer(size8, posn8, addr16, mask8, expectedValue8) : status | timeout, bStatusOK
    status := VL53L5CX_STATUS_OK

    timeout := 0

    repeat
        'status |= RdMulti(&(p_dev->platform), addr16, p_dev->temp_buffer, size8)
        bStatusOK := readBytes(addr16, size8, @tempBuffer)
        ' status |= WaitMs(&(p_dev->platform), 10)
        waitus(10)

        if (timeout >= 200) '  2s timeout
            ' status |= p_dev->temp_buffer[2]
            status |= BYTE[@tempBuffer][2]
        elseif ((size8 >= 4) and (BYTE[@tempBuffer][2] >= $7f))
            status := VL53L5CX_MCU_ERROR
            quit
        else
            timeout++

    while ((BYTE[@tempBuffer][posn8] & mask8) <> expectedValue8)

PRI sendOffsetData(resolution, pSourceBytes, nLenSourceBytes) : status | j, i, k
' Inner function, not available outside this file. This function is used
'  to set the offset data gathered from NVM.
	status := VL53L5CX_STATUS_OK

	BYTEMOVE(@ofsTempBuffer, pSourceBytes, VL53L5CX_OFFSET_BUFFER_SIZE)             ' (void)memcpy(p_dev->temp_buffer, p_dev->offset_data, VL53L5CX_OFFSET_BUFFER_SIZE)

	' Data extrapolation is required for 4X4 offset
	if resolution == VL53L5CX_RESOLUTION_4X4
		BYTEMOVE(@BYTE[@ofsTempBuffer][$10], @dss_4x4Ofs, 8)                        ' (void)memcpy(&(p_dev->temp_buffer[0x10]), dss_4x4Ofs, sizeof(dss_4x4Ofs))
        ' convert tempBuffer into device byte-order
		swapBuffer(@ofsTempBuffer, VL53L5CX_OFFSET_BUFFER_SIZE)

        ' extract signal grid
		BYTEMOVE(@signal_grid, @BYTE[@ofsTempBuffer][$3c], SIGNAL_GRID_SIZE_BYTES)  ' (void)memcpy(signal_grid, &(p_dev->temp_buffer[0x3C]), sizeof(signal_grid))
        ' extract range grid
		BYTEMOVE(@range_grid, @BYTE[@ofsTempBuffer][$140], RANGE_GRID_SIZE_BYTES)   ' (void)memcpy(range_grid, &(p_dev->temp_buffer[0x140]), sizeof(range_grid))

		repeat j from 0 to 4 - 1                                                    ' for (j = 0 j < (int8_t)4 j++)
			repeat i from 0 to 4 - 1                                                ' for (i = 0 i < (int8_t)4 i++)
				BYTE[@signal_grid][i + (4 * j)] := (BYTE[@signal_grid][(2 * i) + (16 * j) + 0] + BYTE[@signal_grid][(2 * i) + (16 * j) + 1] + BYTE[@signal_grid][(2 * i) + (16 * j) + 8] + BYTE[@signal_grid][(2 * i) + (16 * j) + 9]) / 4
				BYTE[@range_grid][i + (4 * j)] := (BYTE[@range_grid][(2 * i) + (16 * j)] + BYTE[@range_grid][(2 * i) + (16 * j) + 1] + BYTE[@range_grid][(2 * i) + (16 * j) + 8] + BYTE[@range_grid][(2 * i) + (16 * j) + 9]) / 4

        ' clear some spaces within range grid
		BYTEFILL(@BYTE[@range_grid][$10], 0, 96)                                    ' (void)memset(&range_grid[0x10], 0, (uint16_t)96)
        ' clear some spaces within signal grid
		BYTEFILL(@BYTE[@signal_grid][$10], 0, 192)                                  ' (void)memset(&signal_grid[0x10], 0, (uint16_t)192)

        ' replace signal grid
		BYTEMOVE(@BYTE[@ofsTempBuffer][$3c], @signal_grid, SIGNAL_GRID_SIZE_BYTES)  ' (void)memcpy(&(p_dev->temp_buffer[0x3C]), signal_grid, sizeof(signal_grid))
        ' replace range grid
		BYTEMOVE(@BYTE[@ofsTempBuffer][$140], @range_grid, RANGE_GRID_SIZE_BYTES)   ' (void)memcpy(&(p_dev->temp_buffer[0x140]), range_grid, sizeof(range_grid))

        ' convert tempBuffer into device byte-order
		swapBuffer(@ofsTempBuffer, VL53L5CX_OFFSET_BUFFER_SIZE)

    ' shift buffer up 8 bytes ?! (removing first 8 bytes, leaving copy of last 8 bytes!)
    '  FIXME: this seems broken as we are moving up 8 but our length is (max - 4) ?? this should be max - 8, right?
	repeat k from 0 to (VL53L5CX_OFFSET_BUFFER_SIZE - 4) - 1                        ' for (k = 0 k < (VL53L5CX_OFFSET_BUFFER_SIZE - (uint16_t)4) k++)
		BYTE[@ofsTempBuffer][k] := BYTE[@ofsTempBuffer][k + 8]                      ' p_dev->temp_buffer[k] = p_dev->temp_buffer[k + 8]

	BYTEMOVE(@BYTE[@ofsTempBuffer][$1e0], @footer, 8)                               ' (void)memcpy(&(p_dev->temp_buffer[0x1E0]), footer, 8)

	' status |= WrMulti(&(p_dev->platform), 0x2e18, p_dev->temp_buffer, VL53L5CX_OFFSET_BUFFER_SIZE)
    status |= writeBytes($2e18, @ofsTempBuffer, VL53L5CX_OFFSET_BUFFER_SIZE)

	' status |= _vl53l5cx_poll_for_answer(p_dev, 4, 1, VL53L5CX_UI_CMD_STATUS, 0xff, 0x03)
    status |= pollForAnswer(4, 1, VL53L5CX_UI_CMD_STATUS, $FF, $03)


PRI sendXtalkData(resolution, pSourceBytes, nLenSourceBytes) : status | j, i
' Inner function, not available outside this file. This function is used
'   to set the Xtalk data from generic configuration, or user's calibration.
	status := VL53L5CX_STATUS_OK

    ' copy external buffer to tempBuffer
	BYTEMOVE(@xtalkTempBuffer, pSourceBytes, VL53L5CX_XTALK_BUFFER_SIZE)        ' (void)memcpy(p_dev->temp_buffer, &(p_dev->xtalk_data[0]), VL53L5CX_XTALK_BUFFER_SIZE)

	' Data extrapolation is required for 4X4 Xtalk
	if (resolution == VL53L5CX_RESOLUTION_4X4)
        ' overlay new values into tempBuffer
		BYTEMOVE(@BYTE[@xtalkTempBuffer][$08], @res4x4, 8)                      ' (void)memcpy(&(p_dev->temp_buffer[0x8]), res4x4, sizeof(res4x4))
		BYTEMOVE(@BYTE[@xtalkTempBuffer][$20], @dss_4x4, 8)                     ' (void)memcpy(&(p_dev->temp_buffer[0x020]), dss_4x4, sizeof(dss_4x4))

        ' convert tempBuffer into device byte-order
		swapBuffer(@xtalkTempBuffer, VL53L5CX_XTALK_BUFFER_SIZE)
        ' extract copy of ordered signal grid
		BYTEMOVE(@signal_grid, @BYTE[@xtalkTempBuffer][$34], 64)                ' (void)memcpy(signal_grid, &(p_dev->temp_buffer[0x34]), sizeof(signal_grid))

        ' recalculate values within signal grid
		repeat j from 0 to 4 - 1                                                ' for (j = 0 j < (int8_t)4 j++)
			repeat i from 0 to 4 - 1                                            ' for (i = 0 i < (int8_t)4 i++)
				BYTE[@signal_grid][i + (4 * j)] := (BYTE[@signal_grid][(2 * i) + (16 * j) + 0] + BYTE[@signal_grid][(2 * i) + (16 * j) + 1] + BYTE[@signal_grid][(2 * i) + (16 * j) + 8] + BYTE[@signal_grid][(2 * i) + (16 * j) + 9]) / 4

        ' clear some spaces within signal grid
		BYTEFILL(@BYTE[@signal_grid][$10], 0, 192)                              ' (void)memset(&signal_grid[0x10], 0, (uint32_t)192)

        ' copy updated signal grid back into temp buffer
		BYTEMOVE(@BYTE[@xtalkTempBuffer][$34], @signal_grid, 64)                ' (void)memcpy(&(p_dev->temp_buffer[0x34]), signal_grid, sizeof(signal_grid))

        ' convert tempBuffer into device byte-order - FIXME: HUH? why doing this again?  Shouldn't only place be here?!!
		swapBuffer(@xtalkTempBuffer, VL53L5CX_XTALK_BUFFER_SIZE)

        ' copy profile_4x4 into temp buffer
		BYTEMOVE(@BYTE[@xtalkTempBuffer][$134], @profile_4x4, 4)                ' (void)memcpy(&(p_dev->temp_buffer[0x134]), profile_4x4, sizeof(profile_4x4))

        ' clear 4 bytes within temp buffer
		BYTEFILL(@BYTE[@xtalkTempBuffer][$078], 0, 4)                           ' (void)memset(&(p_dev->temp_buffer[0x078]), 0, (uint32_t)4 * sizeof(uint8_t))

    ' write temp buffer out to device
	' status |= WrMulti(&(p_dev->platform), 0x2cf8, p_dev->temp_buffer, VL53L5CX_XTALK_BUFFER_SIZE)
    status |= writeBytes($2cf8, @xtalkTempBuffer, VL53L5CX_XTALK_BUFFER_SIZE)
	' status |= _vl53l5cx_poll_for_answer(p_dev, 4, 1, VL53L5CX_UI_CMD_STATUS, 0xff, 0x03)
    status |= pollForAnswer(4, 1, VL53L5CX_UI_CMD_STATUS, $FF, $03)


PRI swapBuffer(pByteArray, nbrBytes) | tmp, i
' Inner function, not available outside this file. This function is used
'  to convert to device required byte order
        '
        ' NOTE:     LOGICAL STORE (VALUE): $1234_5678 (bytes in register)
        '    while PHYSICAL STORE(IN-RAM): $7856_3412 (bytes in RAM)
        '
    ' FIXME: verify above reality against code-actual below (correct the code)
	repeat i from 0 to nbrBytes - 1 step 4                                      ' for (i = 0 i < size i = i + 4)
		tmp := (BYTE[pByteArray][i] << 24) | (BYTE[pByteArray][i + 1] << 16) | (BYTE[pByteArray][i + 2] << 8) | (BYTE[pByteArray][i + 3])
        LONGFILL(@BYTE[pByteArray][i], tmp, 1)                                  ' memcpy(&(LONG[pByteArray][i]), &tmp, 4)


PRI dciReplaceData(pDataBffr, register16, dataBffrSize, pNewData, newDataSize, newDataOfst) : status
' REF uint8_t vl53l5cx_dci_replace_data(p_dev, *data, index, data_size, *new_data, new_data_size, new_data_pos)
	status := VL53L5CX_STATUS_OK

    status |= readBytes(register16, dataBffrSize, pDataBffr)        ' status |= vl53l5cx_dci_read_data(p_dev, data, index, data_size)

    BYTEMOVE(@BYTE[pDataBffr][newDataOfst], pNewData, newDataSize)  ' (void)memcpy(&(data[new_data_pos]), new_data, new_data_size)

	status |= writeBytes(register16, pDataBffr, dataBffrSize)       ' status |= vl53l5cx_dci_write_data(p_dev, data, index, data_size)


CON '  ---- Device reads & writes ----

    I2C_MODE_READ               = %0000_0001
    I2C_MODE_WRITE              = %0000_0000

PRI writeByte(regAddr16, dataValue8) : ok | ackbit
    ' Write {dataValue8} to register {regAddr16}
    i2c_bus.start()
    ok := ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_WRITE)
    ackBit := i2c_bus.write(regAddr16.byte[1])
    ok |= ackbit
    ackBit := i2c_bus.write(regAddr16.byte[0])
    ok |= ackbit
    ackBit := i2c_bus.write(dataValue8)
    ok |= ackbit
    i2c_bus.stop()

    'if bShowDebug
    ' following is more than 10ms...
    '    term.fstr3(string("* writeByte(0x%.02x)=0x%.02x ok:%d' 10), regAddr16, dataValue8, ok)


PRI writeBytes(regAddr16, pByteStore, byteCount) : ok | ackbit, byteIndex, endAckNak, result8
    ' Write {byteCount} BYTEs from BYTE array located at {pByteStore} -  to {regAddr16}+0, to {regAddr16}+1,
    '  to {regAddr16}+2 and so on
    i2c_bus.start()
    ok := ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_WRITE)
    ackBit := i2c_bus.write(regAddr16.byte[0])
    ok |= ackbit
    ackBit := i2c_bus.write(regAddr16.byte[1])
    ok |= ackbit
    repeat byteIndex from 0 to byteCount - 1
        endAckNak := (byteIndex == byteCount - 1) ? i2c_bus.NAK : i2c_bus.ACK
        ackBit := i2c_bus.write(BYTE [pByteStore][byteIndex])
    i2c_bus.stop()

    'if bShowDebug
    ' following is more than 10ms...
    '    term.fstr3(string("* writeBytes(0x%.02x, ct=%d)=0x%.04x ok:%d' 10), regAddr16, byteCount, pByteStore, ok)


PRI readByte(regAddr16) : ok, result8 | ackbit
    ' Read {result16} from register {regAddr16}
    i2c_bus.start()
    ok := ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_WRITE)
    ackBit := i2c_bus.write(regAddr16.byte[1])
    ok |= ackbit
    ackBit := i2c_bus.write(regAddr16.byte[0])
    ok |= ackbit
    i2c_bus.start()
    ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_READ)
    ok |= ackbit
    result8 := i2c_bus.read(i2c_bus.NAK)
    i2c_bus.stop()
    'if bShowDebug
    '    'debug(`snsLog ' * readByte(0x%.02x) ok:%d, byt=0x%.02x, ret %d' 10), regAddr16, ok, result8, result8)
    debug(" -rdBy: ", udec(ok), uhex_byte(regAddr16), uhex_byte(result8))


PRI readBytes(regAddr16, byteCount, pByteStore) : ok | ackbit, byteIndex, endAckNak, result8
    ' Read {byteCount} BYTEs starting from register {regAddr16} - byte from {regAddr16},
    '  byte from {regAddr16}+1, byte from {regAddr16}+2, byte from {regAddr16}+3 and so on
    '  placing them into BYTE array located at {pByteStore}

    'if bShowDebug
    '    term.fstr2(string("* readBytes(0x%.02x, ct=%d)' 10), regAddr16, byteCount)
    i2c_bus.start()
    ok := ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_WRITE)
    ackBit := i2c_bus.write(regAddr16.byte[1])
    ok |= ackbit
    ackBit := i2c_bus.write(regAddr16.byte[0])
    ok |= ackbit
    i2c_bus.start()
    ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_READ)
    ok |= ackbit
    repeat byteIndex from 0 to byteCount - 1
        endAckNak := (byteIndex == byteCount - 1) ? i2c_bus.NAK : i2c_bus.ACK
        result8 := i2c_bus.read(endAckNak)
        result8 := result8 signx 7
        BYTE [pByteStore][byteIndex] := result8
        'if bShowDebug
        '    term.fstr5(string(" -- readBytes(0x%.02x) ok:%d, BYTE[%d]ret 0x%.02x(%d)' 10), regAddr16 + byteIndex, ok, byteIndex, result8, result8)
    i2c_bus.stop()
    'if bShowDebug
    '    term.fstr3(string(" -- readBytes(0x%.02x, ct=%d) ok:%d' 10), regAddr16, byteCount, ok)


PRI writeWord(regAddr16, dataValue16) : ok | ackbit
    ' Write {dataValue16} to register {regAddr16} - hi byte to {regAddr16}, lo byte to {regAddr16}+1
    i2c_bus.start()
    ok := ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_WRITE)
    ackBit := i2c_bus.write(regAddr16.byte[0])
    ok |= ackbit
    ackBit := i2c_bus.write(regAddr16.byte[1])
    ok |= ackbit
    ackBit := i2c_bus.write(dataValue16.byte[1])
    ok |= ackbit
    ackBit := i2c_bus.write(dataValue16.byte[0])
    ok |= ackbit
    i2c_bus.stop()
    waitms(2)  ' after each write!

    'if bShowDebug
    ' following is more than 10ms...
    '    term.fstr3(string("* writeWord(0x%.02x)=0x%.04x ok:%d' 10), regAddr16, dataValue16, ok)


PRI readWord(regAddr16) : ok, result16 | ackbit
    ' Read {result16} from register {regAddr16} - hi byte from {regAddr16}, lo byte from {regAddr16}+1
    i2c_bus.start()
    ok := ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_WRITE)
    ackBit := i2c_bus.write(regAddr16.byte[0])
    ok |= ackbit
    ackBit := i2c_bus.write(regAddr16.byte[1])
    ok |= ackbit
    i2c_bus.start()
    ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_READ)
    ok |= ackbit
    result16.byte[1] := i2c_bus.read(i2c_bus.ACK)
    result16.byte[0] := i2c_bus.read(i2c_bus.NAK)
    i2c_bus.stop()
    result16 := result16 signx 15   ' sign extend
    'if bShowDebug
    '    term.fstr5(string("* readWord(0x%.02x) ok:%d, hi 0x%.02x, lo 0x%.02x, ret %d' 10), regAddr16, ok, result16.byte[1], result16.byte[0], result16)
    debug(" -rdWd: ", udec(ok), uhex_byte(regAddr16), uhex_word(result16))


PRI readWords(regAddr16, wordCount, pWordStore) : ok | ackbit, wordIndex, endAckNak, result16
    ' Read {wordCount} WORDs starting from register {regAddr16} - hi byte from {regAddr16},
    '  lo byte from {regAddr16}+1, hi byte from {regAddr16}+2, lo byte from {regAddr16}+3 and so on
    '  placing them into WORD array located at {pWordStore}

    'if bShowDebug
    '    term.fstr2(string("* readWords(0x%.02x, ct=%d)' 10), regAddr16, wordCount)
    i2c_bus.start()
    ok := ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_WRITE)
    ackBit := i2c_bus.write(regAddr16)
    ok |= ackbit
    i2c_bus.start()
    ackBit := i2c_bus.write((dvcI2CAddr << 1) | I2C_MODE_READ)
    ok |= ackbit
    repeat wordIndex from 0 to wordCount - 1
        endAckNak := (wordIndex == wordCount - 1) ? i2c_bus.NAK : i2c_bus.ACK
        result16.byte[1] := i2c_bus.read(i2c_bus.ACK)
        result16.byte[0] := i2c_bus.read(endAckNak)
        result16 := result16 signx 15   ' sign extend
        WORD [pWordStore][wordIndex] := result16
        'if bShowDebug
        '    term.fstr7(string(" -- readWords(0x%.02x) ok:%d, hi:0x%.02x, lo:0x%.02x, WORD[%d]ret 0x%.04x(%d)' 10), regAddr16 + (wordIndex * 2), ok, result16.byte[1], result16.byte[0], wordIndex, result16, result16)
    i2c_bus.stop()
    'if bShowDebug
    '    term.fstr3(string(" -- readWords(0x%.02x, ct=%d) ok:%d' 10), regAddr16, wordCount, ok)
    debug("readWords: ", uhex_byte(regAddr16), udec_long(wordCount))
    repeat wordIndex from 0 to wordCount - 1
        debug("  #", udec_byte_(wordIndex), " ", uhex_word_(WORD [pWordStore][wordIndex]))



DAT { Data for PRIVATE Methods }
	signal_grid     LONG    0[SIGNAL_GRID_SIZE_BYTES]
	range_grid      WORD    0[RANGE_GRID_SIZE_BYTES]

	dss_4x4Ofs      BYTE    $0F, $04, $04, $00, $08, $10, $10, $07
	footer          BYTE    $00, $00, $00, $0F, $03, $01, $01, $E4

	res4x4          BYTE    $0F, $04, $04, $17, $08, $10, $10, $07
	dss_4x4         BYTE    $00, $78, $00, $08, $00, $00, $00, $08
	profile_4x4     BYTE    $A0, $FC, $01, $00

    ' FIXME: convert following to single buffer if conditional constant assignment above compiles
    xtalkTempBuffer BYTE    0[VL53L5CX_XTALK_BUFFER_SIZE]   ' 776 bytes
    ofsTempBuffer   BYTE    0[VL53L5CX_OFFSET_BUFFER_SIZE]    ' 488 bytes



DAT { fixed driver tables }

' This buffer contains the VL53L5CX default Xtalk data.
    VL53L5CX_DEFAULT_XTALK          BYTE     $9f,  $d8,  $00,  $c0, $03,  $20,  $09,  $60, $0b,  $08,  $08,  $17, $08,  $08,  $08,  $03     ' $00000 - $0000f
                                    BYTE     $9f,  $e4,  $01,  $40, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00010 - $0001f
                                    BYTE     $01,  $e0,  $00,  $20, $00,  $00,  $00,  $20, $9f,  $f8,  $00,  $40, $17,  $17,  $17,  $17     ' $00020 - $0002f
                                    BYTE     $9f,  $fc,  $04,  $04, $00,  $00,  $46,  $a4, $00,  $00,  $37,  $66, $00,  $00,  $26,  $60     ' $00030 - $0003f
                                    BYTE     $00,  $00,  $1c,  $bc, $00,  $00,  $17,  $73, $00,  $00,  $11,  $25, $00,  $00,  $11,  $07     ' $00040 - $0004f
                                    BYTE     $00,  $00,  $0e,  $63, $00,  $00,  $8b,  $4c, $00,  $00,  $60,  $a2, $00,  $00,  $3d,  $c0     ' $00050 - $0005f
                                    BYTE     $00,  $00,  $26,  $aa, $00,  $00,  $1b,  $c2, $00,  $00,  $18,  $04, $00,  $00,  $14,  $97     ' $00060 - $0006f
                                    BYTE     $00,  $00,  $10,  $ed, $00,  $01,  $28,  $1b, $00,  $00,  $93,  $f0, $00,  $00,  $57,  $61     ' $00070 - $0007f
                                    BYTE     $00,  $00,  $30,  $2b, $00,  $00,  $20,  $aa, $00,  $00,  $1a,  $b6, $00,  $00,  $15,  $c3     ' $00080 - $0008f
                                    BYTE     $00,  $00,  $16,  $0e, $00,  $01,  $7f,  $bb, $00,  $00,  $ad,  $58, $00,  $00,  $71,  $af     ' $00090 - $0009f
                                    BYTE     $00,  $00,  $36,  $d9, $00,  $00,  $22,  $fb, $00,  $00,  $1c,  $96, $00,  $00,  $18,  $83     ' $000a0 - $000af
                                    BYTE     $00,  $00,  $17,  $96, $00,  $01,  $90,  $00, $00,  $00,  $97,  $d6, $00,  $00,  $66,  $3b     ' $000b0 - $000bf
                                    BYTE     $00,  $00,  $33,  $0a, $00,  $00,  $20,  $cd, $00,  $00,  $19,  $38, $00,  $00,  $16,  $a5     ' $000c0 - $000cf
                                    BYTE     $00,  $00,  $14,  $bb, $00,  $00,  $af,  $cf, $00,  $00,  $65,  $7d, $00,  $00,  $3d,  $93     ' $000d0 - $000df
                                    BYTE     $00,  $00,  $29,  $d1, $00,  $00,  $19,  $4e, $00,  $00,  $15,  $ba, $00,  $00,  $11,  $c6     ' $000e0 - $000ef
                                    BYTE     $00,  $00,  $12,  $7f, $00,  $00,  $73,  $1d, $00,  $00,  $42,  $2c, $00,  $00,  $2e,  $82     ' $000f0 - $000ff
                                    BYTE     $00,  $00,  $1e,  $80, $00,  $00,  $18,  $1c, $00,  $00,  $13,  $2d, $00,  $00,  $0f,  $c6     ' $00100 - $0010f
                                    BYTE     $00,  $00,  $0f,  $85, $00,  $00,  $4f,  $04, $00,  $00,  $33,  $e9, $00,  $00,  $1f,  $06     ' $00110 - $0011f
                                    BYTE     $00,  $00,  $18,  $40, $00,  $00,  $13,  $2c, $00,  $00,  $12,  $97, $00,  $00,  $0e,  $01     ' $00120 - $0012f
                                    BYTE     $00,  $00,  $0d,  $ac, $a0,  $fc,  $01,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $03     ' $00130 - $0013f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $a1,  $0c,  $01,  $00, $00,  $00,  $00,  $80     ' $00140 - $0014f
                                    BYTE     $00,  $00,  $00,  $03, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $a1,  $1c,  $00,  $c0     ' $00150 - $0015f
                                    BYTE     $00,  $00,  $70,  $eb, $0c,  $80,  $01,  $e0, $00,  $00,  $00,  $26, $a1,  $28,  $09,  $02     ' $00160 - $0016f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $01,  $00,  $00     ' $00170 - $0017f
                                    BYTE     $00,  $36,  $00,  $03, $01,  $d9,  $01,  $43, $02,  $33,  $02,  $17, $02,  $4b,  $02,  $41     ' $00180 - $0018f
                                    BYTE     $01,  $17,  $02,  $22, $00,  $27,  $00,  $5d, $00,  $05,  $00,  $11, $00,  $00,  $00,  $01     ' $00190 - $0019f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $001a0 - $001af
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $001b0 - $001bf
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $001c0 - $001cf
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $001d0 - $001df
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $001e0 - $001ef
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $001f0 - $001ff
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00200 - $0020f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00210 - $0021f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00220 - $0022f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00230 - $0023f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00240 - $0024f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00250 - $0025f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00260 - $0026f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00270 - $0027f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00280 - $0028f
                                    BYTE     $a2,  $48,  $00,  $40, $00,  $00,  $00,  $00, $a2,  $4c,  $00,  $81, $00,  $00,  $00,  $00     ' $00290 - $0029f
                                    BYTE     $00,  $00,  $00,  $00, $a2,  $54,  $00,  $81, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $002a0 - $002af
                                    BYTE     $a2,  $5c,  $00,  $81, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $a2,  $64,  $00,  $81     ' $002b0 - $002bf
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $a2,  $6c,  $00,  $84, $00,  $00,  $00,  $00     ' $002c0 - $002cf
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $002d0 - $002df
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $a2,  $8c,  $00,  $82     ' $002e0 - $002ef
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $002f0 - $002ff
                                    BYTE     $00,  $00,  $00,  $0F, $05,  $01,  $03,  $04
    VL53L5CX_DEFAULT_XTALK_END
    VL53L5CX_DEFAULT_XTALK_LEN  LONG   @VL53L5CX_DEFAULT_XTALK_END - @VL53L5CX_DEFAULT_XTALK

    ' This buffer is used to get NVM data.
    VL53L5CX_GET_NVM_CMD            BYTE   $54,  $00,  $00,  $40, $9E,  $14,  $00,  $C0, $9E,  $20,  $01,  $40, $9E,  $34,  $00,  $40       ' $00000 - $0000f
                                    BYTE   $9E,  $38,  $04,  $04, $9F,  $38,  $04,  $02, $9F,  $B8,  $01,  $00, $9F,  $C8,  $01,  $00       ' $00010 - $0001f
                                    BYTE   $00,  $00,  $00,  $0F, $02,  $02,  $00,  $24                                                     ' $00020 - $00027
    VL53L5CX_GET_NVM_CMD_END
    VL53L5CX_GET_NVM_CMD_LEN        LONG   @VL53L5CX_GET_NVM_CMD_END - @VL53L5CX_GET_NVM_CMD

    ' This buffer contains the VL53L5CX default configuration.
    VL53L5CX_DEFAULT_CONFIGURATION  BYTE     $54,  $50,  $00,  $80, $00,  $04,  $04,  $04, $00,  $00,  $08,  $08, $AD,  $30,  $00,  $80     ' $00000 - $0000f
                                    BYTE     $02,  $01,  $03,  $03, $00,  $00,  $03,  $00, $AD,  $38,  $01,  $00, $01,  $E0,  $01,  $40     ' $00010 - $0001f
                                    BYTE     $00,  $40,  $00,  $40, $01,  $00,  $04,  $00, $00,  $00,  $00,  $01, $54,  $58,  $00,  $40     ' $00020 - $0002f
                                    BYTE     $04,  $1A,  $01,  $00, $54,  $5C,  $01,  $40, $00,  $00,  $27,  $10, $00,  $00,  $0F,  $A0     ' $00030 - $0003f
                                    BYTE     $0F,  $A0,  $03,  $E8, $02,  $80,  $1F,  $40, $00,  $00,  $05,  $00, $54,  $70,  $00,  $80     ' $00040 - $0004f
                                    BYTE     $03,  $20,  $03,  $20, $00,  $00,  $00,  $08, $54,  $78,  $01,  $00, $01,  $13,  $00,  $29     ' $00050 - $0005f
                                    BYTE     $00,  $33,  $00,  $00, $02,  $00,  $00,  $01                                                   ' $00060 - $00067
                                    BYTE     $04,  $01,  $08, VL53L5CX_FW_NBTAR_RANGING, $54,  $88,  $01,  $40                              ' $00068 - $0006f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00070 - $0007f
                                    BYTE     $00,  $00,  $0C,  $00, $AD,  $48,  $01,  $00, $01,  $F4,  $00,  $00, $03,  $06,  $00,  $10     ' $00080 - $0008f
                                    BYTE     $08,  $07,  $08,  $07, $00,  $00,  $00,  $08, $AD,  $60,  $01,  $00, $00,  $00,  $00,  $80     ' $00090 - $0009f
                                    BYTE     $00,  $00,  $00,  $00, $20,  $1F,  $01,  $F4, $00,  $00,  $1D,  $0A, $AD,  $70,  $00,  $80     ' $000a0 - $000af
                                    BYTE     $08,  $00,  $1F,  $40, $00,  $00,  $00,  $01, $AD,  $78,  $00,  $80, $00,  $A0,  $03,  $20     ' $000b0 - $000bf
                                    BYTE     $00,  $01,  $01,  $90, $AD,  $80,  $00,  $40, $00,  $00,  $28,  $00, $AD,  $84,  $00,  $80     ' $000c0 - $000cf
                                    BYTE     $00,  $00,  $32,  $00, $03,  $20,  $00,  $00, $AD,  $8C,  $00,  $80, $02,  $58,  $FF,  $38     ' $000d0 - $000df
                                    BYTE     $00,  $00,  $00,  $0C, $AD,  $94,  $01,  $00, $00,  $01,  $90,  $00, $FF,  $FF,  $FC,  $00     ' $000e0 - $000ef
                                    BYTE     $00,  $00,  $04,  $00, $00,  $00,  $01,  $01, $AD,  $A4,  $00,  $C0, $04,  $80,  $06,  $1A     ' $000f0 - $000ff
                                    BYTE     $00,  $40,  $05,  $80, $00,  $00,  $01,  $06, $AD,  $B0,  $00,  $C0, $04,  $80,  $06,  $1A     ' $00100 - $0010f
                                    BYTE     $19,  $00,  $05,  $80, $00,  $00,  $01,  $90, $AD,  $BC,  $04,  $40, $00,  $00,  $00,  $00     ' $00110 - $0011f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $12,  $00,  $25, $00,  $00,  $00,  $06, $00,  $00,  $00,  $05     ' $00120 - $0012f
                                    BYTE     $00,  $00,  $00,  $05, $00,  $00,  $00,  $06, $00,  $00,  $00,  $04, $00,  $00,  $00,  $0F     ' $00130 - $0013f
                                    BYTE     $00,  $00,  $00,  $5A, $00,  $00,  $00,  $00, $00,  $00,  $00,  $09, $0B,  $0C,  $0B,  $0B     ' $00140 - $0014f
                                    BYTE     $03,  $03,  $11,  $05, $01,  $01,  $01,  $01, $00,  $00,  $00,  $00, $00,  $0D,  $00,  $00     ' $00150 - $0015f
                                    BYTE     $AE,  $00,  $01,  $04, $00,  $00,  $00,  $04, $00,  $00,  $00,  $08, $00,  $00,  $00,  $0A     ' $00160 - $0016f
                                    BYTE     $00,  $00,  $00,  $0C, $00,  $00,  $00,  $0D, $00,  $00,  $00,  $0E, $00,  $00,  $00,  $08     ' $00170 - $0017f
                                    BYTE     $00,  $00,  $00,  $08, $00,  $00,  $00,  $10, $00,  $00,  $00,  $10, $00,  $00,  $00,  $20     ' $00180 - $0018f
                                    BYTE     $00,  $00,  $00,  $20, $00,  $00,  $00,  $06, $00,  $00,  $05,  $0A, $02,  $00,  $0C,  $08     ' $00190 - $0019f
                                    BYTE     $00,  $00,  $00,  $00, $AE,  $40,  $00,  $40, $00,  $00,  $01,  $FF, $AE,  $44,  $00,  $40     ' $001a0 - $001af
                                    BYTE     $00,  $10,  $04,  $01, $AE,  $48,  $00,  $40, $00,  $00,  $10,  $00, $AE,  $4C,  $00,  $40     ' $001b0 - $001bf
                                    BYTE     $00,  $00,  $00,  $01, $AE,  $50,  $01,  $40, $00,  $00,  $00,  $14, $04,  $00,  $28,  $00     ' $001c0 - $001cf
                                    BYTE     $03,  $20,  $6C,  $00, $00,  $00,  $00,  $00, $00,  $00,  $25,  $80, $AE,  $64,  $00,  $40     ' $001d0 - $001df
                                    BYTE     $00,  $00,  $00,  $02, $AE,  $D8,  $01,  $00, $00,  $C8,  $05,  $DC, $00,  $00,  $0C,  $CD     ' $001e0 - $001ef
                                    BYTE     $01,  $04,  $00,  $00, $00,  $00,  $26,  $01, $B5,  $50,  $02,  $82, $00,  $00,  $00,  $00     ' $001f0 - $001ff
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00200 - $0020f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00210 - $0021f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00220 - $0022f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00230 - $0023f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $B5,  $A0,  $02,  $82     ' $00240 - $0024f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00250 - $0025f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00260 - $0026f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00270 - $0027f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00280 - $0028f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00290 - $0029f
                                    BYTE     $B5,  $F0,  $00,  $40, $00,  $FF,  $00,  $00, $B3,  $9C,  $01,  $00, $40,  $00,  $05,  $1E     ' $002a0 - $002af
                                    BYTE     $02,  $1B,  $08,  $7C, $80,  $01,  $12,  $01, $00,  $00,  $08,  $00, $B6,  $C0,  $00,  $C0     ' $002b0 - $002bf
                                    BYTE     $00,  $00,  $60,  $00, $00,  $00,  $20,  $00, $00,  $00,  $00,  $00, $AE,  $A8,  $00,  $40     ' $002c0 - $002cf
                                    BYTE     $00,  $00,  $04,  $05, $AE,  $AC,  $00,  $80, $01,  $00,  $01,  $00, $00,  $02,  $00,  $00     ' $002d0 - $002df
                                    BYTE     $AE,  $B4,  $00,  $40, $00,  $00,  $00,  $00, $AE,  $B8,  $00,  $81, $00,  $00,  $00,  $00     ' $002e0 - $002ef
                                    BYTE     $00,  $00,  $00,  $00, $AE,  $C0,  $00,  $81, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $002f0 - $002ff
                                    BYTE     $AE,  $C8,  $00,  $81, $08,  $01,  $01,  $08, $00,  $00,  $00,  $08, $AE,  $D0,  $00,  $81     ' $00300 - $0030f
                                    BYTE     $01,  $08,  $08,  $08, $00,  $00,  $00,  $01, $B5,  $F4,  $00,  $80, $00,  $00,  $00,  $00     ' $00310 - $0031f
                                    BYTE     $00,  $00,  $00,  $00, $B5,  $FC,  $00,  $80, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00320 - $0032f
                                    BYTE     $B6,  $04,  $00,  $40, $00,  $00,  $00,  $00, $B6,  $08,  $00,  $44, $00,  $00,  $00,  $00     ' $00330 - $0033f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $B6,  $18,  $00,  $44     ' $00340 - $0034f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00350 - $0035f
                                    BYTE     $B6,  $28,  $00,  $44, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00360 - $0036f
                                    BYTE     $00,  $00,  $00,  $00, $B6,  $38,  $00,  $44, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $00370 - $0037f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $B6,  $48,  $01,  $00, $00,  $00,  $00,  $00     ' $00380 - $0038f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $B6,  $58,  $01,  $00     ' $00390 - $0039f
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $002a0 - $003af
                                    BYTE     $B6,  $68,  $01,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00, $00,  $00,  $00,  $00     ' $003b0 - $003bf
                                    BYTE     $00,  $00,  $00,  $00, $00,  $00,  $00,  $0F, $00,  $01,  $03,  $c8
    VL53L5CX_DEFAULT_CONFIG_END
    VL53L5CX_DEFAULT_CONFIG_LEN  LONG    @VL53L5CX_DEFAULT_CONFIG_END - @VL53L5CX_DEFAULT_CONFIGURATION

' This buffer contains the VL53L5CX firmware (MM1.1)
    VL53L5CX_FIRMWARE     BYTE
    FILE  "vl53l5cx_mm1_1_fw.dat"   ' load binary data here 86,016 bytes ($15_000)
    VL53L5CX_FIRMWARE_END
    VL53L5CX_FIRMWARE_LEN  LONG    @VL53L5CX_FIRMWARE_END - @VL53L5CX_FIRMWARE

CON { --- license --- }

{{

 -------------------------------------------------------------------------------------------------
  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 =================================================================================================
}}
